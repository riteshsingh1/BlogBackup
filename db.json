{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"source/assets/blogImg/interview-top.jpg","path":"assets/blogImg/interview-top.jpg","modified":0,"renderable":0},{"_id":"source/assets/blogImg/liuzhida33.png","path":"assets/blogImg/liuzhida33.png","modified":0,"renderable":0},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"source/assets/img/alipay.jpg","path":"assets/img/alipay.jpg","modified":0,"renderable":0},{"_id":"source/assets/blogImg/cocoapods-top.jpg","path":"assets/blogImg/cocoapods-top.jpg","modified":0,"renderable":0},{"_id":"source/assets/img/weixin.jpg","path":"assets/img/weixin.jpg","modified":0,"renderable":0},{"_id":"source/assets/blogImg/http-https-top.jpg","path":"assets/blogImg/http-https-top.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"898819b9a37df9f380d9365c0c0aa899072bab9a","modified":1524123897470},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1524121177585},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1524121177585},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1524121177585},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1524121177585},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1524121177585},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1524121177586},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1524121177586},{"_id":"themes/yilia/_config.yml","hash":"34cba07e59046b375aded1c488768a357752e4f4","modified":1524129243122},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1524121177596},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1524121177624},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1524126793620},{"_id":"source/_posts/Cocoapods-Podfile-Arguments.md","hash":"f805dc8fd5214e2fcdb87fc3a0c7bf8e75dcf5d0","modified":1524129017250},{"_id":"source/_posts/InterviewQuestions-20180414.md","hash":"49f2a33f95395b7157e80e7de46fe78c250e7d41","modified":1524128765298},{"_id":"source/_posts/HTTP-and-HTTPS.md","hash":"afaca1c1bd42fd1393d582c796180a3c330726df","modified":1524130087714},{"_id":"source/assets/.DS_Store","hash":"cafa04d1fe393ffe461a358b30aad15b030c49b8","modified":1524123882827},{"_id":"source/photos/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1524126463201},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1524121177578},{"_id":"themes/yilia/.git/FETCH_HEAD","hash":"1efc9d034adf6456e816fcbb20023807ca64bbd0","modified":1524121207323},{"_id":"themes/yilia/.git/ORIG_HEAD","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1524121207336},{"_id":"themes/yilia/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1524121177579},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1524121142921},{"_id":"themes/yilia/.git/index","hash":"816f0db337eab9e0a37deae5be667074ab8781bb","modified":1524121177625},{"_id":"themes/yilia/.git/packed-refs","hash":"83644c3638dafa38c817265c9207f098dd8aeee6","modified":1524121177576},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1524121177586},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1524121177587},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1524121177587},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1524121177587},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1524121177587},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1524121177587},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1524121177587},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1524121177595},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1524121177595},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1524121177595},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1524121177595},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1524121177596},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1524121177596},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1524121177596},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1524121177621},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1524121177624},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1524121177597},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1524121177617},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1524121177594},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1524121177622},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1524121177623},{"_id":"source/assets/blogImg/interview-top.jpg","hash":"4b61833915d4361c517144d8479886c0b834c9fb","modified":1524128904950},{"_id":"source/assets/blogImg/liuzhida33.png","hash":"2d6eef187bf280d2a213cfa5f88306fa00cea21a","modified":1524123731464},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1524121142922},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1524121142922},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1524121142923},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1524121142924},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1524121142922},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1524121142924},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1524121142922},{"_id":"themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1524121142923},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1524121142923},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1524121142924},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1524121142921},{"_id":"themes/yilia/.git/logs/HEAD","hash":"6cae1b7aa84308dbe0d46f27cc967f78c9822d13","modified":1524121177578},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1524121177588},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1524121177588},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1524121177588},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1524121177588},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1524121177589},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1524121177589},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1524121177588},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1524121177589},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1524121177589},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1524121177589},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1524121177589},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1524121177590},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1524121177590},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1524121177590},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1524121177594},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1524121177594},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1524121177617},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1524121177618},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1524121177618},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1524121177618},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1524121177619},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1524121177619},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1524121177619},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1524121177620},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1524121177620},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1524121177597},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1524121177597},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1524121177598},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1524121177598},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1524121177599},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1524121177598},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1524121177599},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1524121177599},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1524121177600},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1524121177602},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1524121177605},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1524121177605},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1524121177605},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1524121177606},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1524121177607},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1524121177608},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1524121177607},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1524121177608},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1524121177608},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1524121177609},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1524121177609},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1524121177610},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1524121177609},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1524121177610},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1524121177610},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1524121177611},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1524121177611},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1524121177612},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1524121177612},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1524121177613},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1524121177613},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1524121177613},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1524121177613},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1524121177614},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1524121177615},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1524121177615},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1524121177615},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1524121177616},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1524121177616},{"_id":"source/assets/img/alipay.jpg","hash":"090631c4daf26723645f2825be76cdd63a1c19cf","modified":1524123637000},{"_id":"source/assets/blogImg/cocoapods-top.jpg","hash":"1414a7bfc86ba8a09e338de08f39b723a1ffe85e","modified":1524127822421},{"_id":"source/assets/img/weixin.jpg","hash":"ce70e725d61157a0557f835d11090d6a3f370265","modified":1524123555000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1524121177594},{"_id":"themes/yilia/.git/objects/pack/pack-fed175727564a00105752e69091b2802e50a4378.idx","hash":"38846b42fab9b4416f3469f9bbb65c7023452783","modified":1524121177563},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1524121177578},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1524121177590},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1524121177591},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1524121177591},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1524121177591},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1524121177591},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1524121177592},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1524121177591},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1524121177592},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1524121177592},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1524121177592},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1524121177603},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1524121177603},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1524121177604},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1524121177605},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1524121177600},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1524121177600},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1524121177601},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1524121177601},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1524121177602},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1524121177606},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1524121177607},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1524121177607},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"6cae1b7aa84308dbe0d46f27cc967f78c9822d13","modified":1524121177579},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1524121177577},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"6cae1b7aa84308dbe0d46f27cc967f78c9822d13","modified":1524121177577},{"_id":"source/assets/blogImg/http-https-top.jpg","hash":"fcb98ddd1f8f5006f6d0d199d98c265f1c126e27","modified":1524129900740},{"_id":"themes/yilia/.git/objects/pack/pack-fed175727564a00105752e69091b2802e50a4378.pack","hash":"f824a2b4b53fe07a19661acf33fa15a4c9867fa0","modified":1524121177562},{"_id":"public/content.json","hash":"cdd514801cb28ed84c56d26d3838bee6473a0e44","modified":1524130652849},{"_id":"public/2018/04/14/InterviewQuestions-20180414/index.html","hash":"d41de7d5b46be5f71b7597275f8dd138819d8a7e","modified":1524130652953},{"_id":"public/2018/04/10/Cocoapods-Podfile-Arguments/index.html","hash":"2ad4ea9fefd7ef4377ee4d79bae191ffa71a35e2","modified":1524130652953},{"_id":"public/2018/04/08/HTTP-and-HTTPS/index.html","hash":"2205ba263e45cd714128643cd463fd0dd7d543d1","modified":1524130652953},{"_id":"public/index.html","hash":"1d4459ee317029287f0e6122e06a9fc1a78a2540","modified":1524130652953},{"_id":"public/archives/index.html","hash":"aea5327c9ccc66ec8a1ed333fbd7e007c16988ba","modified":1524130652953},{"_id":"public/archives/2018/index.html","hash":"8fa9d3345d02ffb68f1d636d24fffa6d383b4774","modified":1524130652954},{"_id":"public/archives/2018/04/index.html","hash":"71e970c1c9c5edee0a44e3115035a1580205e4bd","modified":1524130652954},{"_id":"public/tags/Podfile/index.html","hash":"558169fc81dbe6daa0e7521939f93829dec84c62","modified":1524130652954},{"_id":"public/tags/Cocoapods/index.html","hash":"965dd578218cb51f2ace3a504c3d946de1081155","modified":1524130652954},{"_id":"public/tags/面试/index.html","hash":"a8a96f47e58af62803a841ecafa230538ff5e401","modified":1524130652954},{"_id":"public/tags/HTTP/index.html","hash":"834591d3e8b2fdfe09d0880278735cfcdae29327","modified":1524130652954},{"_id":"public/tags/HTTPS/index.html","hash":"5184c77f1c88758e193cf70c96b3729fcaa66210","modified":1524130652954},{"_id":"public/tags/握手/index.html","hash":"ba809fd74272a6e3075189cab2cffd0c87161e33","modified":1524130652954},{"_id":"public/assets/blogImg/interview-top.jpg","hash":"4b61833915d4361c517144d8479886c0b834c9fb","modified":1524130652959},{"_id":"public/assets/blogImg/liuzhida33.png","hash":"2d6eef187bf280d2a213cfa5f88306fa00cea21a","modified":1524130652959},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1524130652959},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1524130652959},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1524130652959},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1524130652959},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1524130652959},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1524130652960},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1524130652960},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1524130652960},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1524130652960},{"_id":"public/assets/img/alipay.jpg","hash":"090631c4daf26723645f2825be76cdd63a1c19cf","modified":1524130652962},{"_id":"public/assets/blogImg/cocoapods-top.jpg","hash":"1414a7bfc86ba8a09e338de08f39b723a1ffe85e","modified":1524130652965},{"_id":"public/assets/img/weixin.jpg","hash":"ce70e725d61157a0557f835d11090d6a3f370265","modified":1524130652965},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1524130652969},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1524130652969},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1524130652969},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1524130652969},{"_id":"public/assets/blogImg/http-https-top.jpg","hash":"fcb98ddd1f8f5006f6d0d199d98c265f1c126e27","modified":1524130652978}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Cocoapods Podfile文件参数剖析","date":"2018-04-10T08:39:25.000Z","_content":"\n![top](/assets/blogImg/cocoapods-top.jpg)\n\n> 文章内容摘自[pluto-y大神](http://www.pluto-y.com/cocoapods-getting-stared/)的博客，感谢大神～\n\n### Podfile文件\n\n<!-- more -->\n\n##### 1. pod '框架名' 参数\n\n- **参数一：版本号。**有大于( `pod 'AFNetworking', '> 3.1'` )、小于( `pod 'AFNetworking', '< 3.1'` )、等于( `pod 'AFNetworking', '3.1'` )、大于等于( `pod 'AFNetworking', '>= 3.1'` )等。**'~> 3.1' 意思是>=3.1 并且<3.2的意思。**\n- **参数二：地址。**地址Cocoapods可以指定某一个git的目录或者是本地的目录，表示一直用最新版本。例如直接在后面接上：`:git => 'https://github.com/XXX/AFNetworking.git'`，或者开发模式下：`:path => '~/Documents/AFNetworking'`。\n- **参数三：tag、branch、commit。**例如：`:branch => 'branch名'`、`:tag => 'tag名'`、`:commit => '提交号'`。\n- **参数四：inhibitallwarnings。**用来避免第三方框架中带来的warnings。例如：`:inhibitallwarnings => true`\n\n##### 2. platform\n\n依赖的库希望在哪个平台被编译。 `platform :ios, '7.0'` 希望采用iOS7.0进行编译。\n\n1. target\n\n   指定具体的配置适配在哪个**target**。\n\n2. use_frameworks!\n\n   指明编译成动态库。**swift下必须有这句话。**\n\n3. source\n\n   指明Cocoapods从哪些仓库中获得框架的源代码。\n\n#### Demo：\n\n```ruby\n# open source\nsource 'https://github.com/CocoaPods/Specs.git'\n\n# 私有源\nsource 'https://github.com/Artsy/Specs.git'\n\n# 指定 iOS9.0 进行编译\nplatform :ios, '9.0'\n\ntarget 'App' do\n  \n  # 编译动态库（swift必须）\n  use_frameworks!\n  \n  pod 'AFNetworking'\n  \n  pod 'SVProgressHUD', '~>2.1' #大于等于2.1，小于2.2\n  \n  pod 'MJRefresh'，:git=> 'https://github.com/XXX/MJRefresh.git' #从 https://github.com/XXX/MJRefresh.git 目录更新cocoapods\n  \n  pod 'Masonry', :git=> 'https://github.com/XXX/MJRefresh.git', :branch => '1-1-stable' #指定从特定的git repo branch更新cocoapod\n  pod 'Masonry', :git=> 'https://github.com/XXX/MJRefresh.git', :tag => '1.3.0' #指定从特定的git repo tag更新cocoapod\n\n  target 'AppTests' do\n    \n    # 编译动态库（swift必须）\n    use_frameworks!\n    \n    pod 'FBSnapshotTestCase'\n    \n  end\nend\n```\n\n### 命令行 `pod install` 和 `pod update`\n\n1. 参数 `--no-repo-update`\n\n在执行`pod install`和`pod update`两条命令时，会执行`pod repo update`的操作，只更新当前项目的第三方框架。\n\n2. 参数`—verbose` 和 `--silent`\n\n用来控制`pod`命令，不希望看到输出的情况时可使用`--silent`。如果出错，可添加`--verbose`显示具体的出错信息。对于大多数的`Cocoapods`的命令行来说都带有着两个参数。\n\n### 更新Ruby\n\n1. 移除Ruby的默认源：\n\n   `gem sources --remove https://rubygems.org/` \n\n2. 替换Ruby China源：\n\n   `gem sources -a https://gems.ruby-china.org/` \n\n3. 验证当前的Ruby源：\n\n   `gem sources -l` ","source":"_posts/Cocoapods-Podfile-Arguments.md","raw":"---\ntitle: Cocoapods Podfile文件参数剖析\ndate: 2018-04-10 16:39:25\ntags:\n- Podfile\n- Cocoapods\n---\n\n![top](/assets/blogImg/cocoapods-top.jpg)\n\n> 文章内容摘自[pluto-y大神](http://www.pluto-y.com/cocoapods-getting-stared/)的博客，感谢大神～\n\n### Podfile文件\n\n<!-- more -->\n\n##### 1. pod '框架名' 参数\n\n- **参数一：版本号。**有大于( `pod 'AFNetworking', '> 3.1'` )、小于( `pod 'AFNetworking', '< 3.1'` )、等于( `pod 'AFNetworking', '3.1'` )、大于等于( `pod 'AFNetworking', '>= 3.1'` )等。**'~> 3.1' 意思是>=3.1 并且<3.2的意思。**\n- **参数二：地址。**地址Cocoapods可以指定某一个git的目录或者是本地的目录，表示一直用最新版本。例如直接在后面接上：`:git => 'https://github.com/XXX/AFNetworking.git'`，或者开发模式下：`:path => '~/Documents/AFNetworking'`。\n- **参数三：tag、branch、commit。**例如：`:branch => 'branch名'`、`:tag => 'tag名'`、`:commit => '提交号'`。\n- **参数四：inhibitallwarnings。**用来避免第三方框架中带来的warnings。例如：`:inhibitallwarnings => true`\n\n##### 2. platform\n\n依赖的库希望在哪个平台被编译。 `platform :ios, '7.0'` 希望采用iOS7.0进行编译。\n\n1. target\n\n   指定具体的配置适配在哪个**target**。\n\n2. use_frameworks!\n\n   指明编译成动态库。**swift下必须有这句话。**\n\n3. source\n\n   指明Cocoapods从哪些仓库中获得框架的源代码。\n\n#### Demo：\n\n```ruby\n# open source\nsource 'https://github.com/CocoaPods/Specs.git'\n\n# 私有源\nsource 'https://github.com/Artsy/Specs.git'\n\n# 指定 iOS9.0 进行编译\nplatform :ios, '9.0'\n\ntarget 'App' do\n  \n  # 编译动态库（swift必须）\n  use_frameworks!\n  \n  pod 'AFNetworking'\n  \n  pod 'SVProgressHUD', '~>2.1' #大于等于2.1，小于2.2\n  \n  pod 'MJRefresh'，:git=> 'https://github.com/XXX/MJRefresh.git' #从 https://github.com/XXX/MJRefresh.git 目录更新cocoapods\n  \n  pod 'Masonry', :git=> 'https://github.com/XXX/MJRefresh.git', :branch => '1-1-stable' #指定从特定的git repo branch更新cocoapod\n  pod 'Masonry', :git=> 'https://github.com/XXX/MJRefresh.git', :tag => '1.3.0' #指定从特定的git repo tag更新cocoapod\n\n  target 'AppTests' do\n    \n    # 编译动态库（swift必须）\n    use_frameworks!\n    \n    pod 'FBSnapshotTestCase'\n    \n  end\nend\n```\n\n### 命令行 `pod install` 和 `pod update`\n\n1. 参数 `--no-repo-update`\n\n在执行`pod install`和`pod update`两条命令时，会执行`pod repo update`的操作，只更新当前项目的第三方框架。\n\n2. 参数`—verbose` 和 `--silent`\n\n用来控制`pod`命令，不希望看到输出的情况时可使用`--silent`。如果出错，可添加`--verbose`显示具体的出错信息。对于大多数的`Cocoapods`的命令行来说都带有着两个参数。\n\n### 更新Ruby\n\n1. 移除Ruby的默认源：\n\n   `gem sources --remove https://rubygems.org/` \n\n2. 替换Ruby China源：\n\n   `gem sources -a https://gems.ruby-china.org/` \n\n3. 验证当前的Ruby源：\n\n   `gem sources -l` ","slug":"Cocoapods-Podfile-Arguments","published":1,"updated":"2018-04-19T09:10:17.250Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg6c1dxv0000gzxfykuktk7b","content":"<p><img src=\"/assets/blogImg/cocoapods-top.jpg\" alt=\"top\"></p>\n<blockquote>\n<p>文章内容摘自<a href=\"http://www.pluto-y.com/cocoapods-getting-stared/\" target=\"_blank\" rel=\"noopener\">pluto-y大神</a>的博客，感谢大神～</p>\n</blockquote>\n<h3 id=\"Podfile文件\"><a href=\"#Podfile文件\" class=\"headerlink\" title=\"Podfile文件\"></a>Podfile文件</h3><a id=\"more\"></a>\n<h5 id=\"1-pod-‘框架名’-参数\"><a href=\"#1-pod-‘框架名’-参数\" class=\"headerlink\" title=\"1. pod ‘框架名’ 参数\"></a>1. pod ‘框架名’ 参数</h5><ul>\n<li><strong>参数一：版本号。</strong>有大于( <code>pod &#39;AFNetworking&#39;, &#39;&gt; 3.1&#39;</code> )、小于( <code>pod &#39;AFNetworking&#39;, &#39;&lt; 3.1&#39;</code> )、等于( <code>pod &#39;AFNetworking&#39;, &#39;3.1&#39;</code> )、大于等于( <code>pod &#39;AFNetworking&#39;, &#39;&gt;= 3.1&#39;</code> )等。<strong>‘~&gt; 3.1’ 意思是&gt;=3.1 并且&lt;3.2的意思。</strong></li>\n<li><strong>参数二：地址。</strong>地址Cocoapods可以指定某一个git的目录或者是本地的目录，表示一直用最新版本。例如直接在后面接上：<code>:git =&gt; &#39;https://github.com/XXX/AFNetworking.git&#39;</code>，或者开发模式下：<code>:path =&gt; &#39;~/Documents/AFNetworking&#39;</code>。</li>\n<li><strong>参数三：tag、branch、commit。</strong>例如：<code>:branch =&gt; &#39;branch名&#39;</code>、<code>:tag =&gt; &#39;tag名&#39;</code>、<code>:commit =&gt; &#39;提交号&#39;</code>。</li>\n<li><strong>参数四：inhibitallwarnings。</strong>用来避免第三方框架中带来的warnings。例如：<code>:inhibitallwarnings =&gt; true</code></li>\n</ul>\n<h5 id=\"2-platform\"><a href=\"#2-platform\" class=\"headerlink\" title=\"2. platform\"></a>2. platform</h5><p>依赖的库希望在哪个平台被编译。 <code>platform :ios, &#39;7.0&#39;</code> 希望采用iOS7.0进行编译。</p>\n<ol>\n<li><p>target</p>\n<p>指定具体的配置适配在哪个<strong>target</strong>。</p>\n</li>\n<li><p>use_frameworks!</p>\n<p>指明编译成动态库。<strong>swift下必须有这句话。</strong></p>\n</li>\n<li><p>source</p>\n<p>指明Cocoapods从哪些仓库中获得框架的源代码。</p>\n</li>\n</ol>\n<h4 id=\"Demo：\"><a href=\"#Demo：\" class=\"headerlink\" title=\"Demo：\"></a>Demo：</h4><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># open source</span></span><br><span class=\"line\">source <span class=\"string\">'https://github.com/CocoaPods/Specs.git'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 私有源</span></span><br><span class=\"line\">source <span class=\"string\">'https://github.com/Artsy/Specs.git'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定 iOS9.0 进行编译</span></span><br><span class=\"line\">platform <span class=\"symbol\">:ios</span>, <span class=\"string\">'9.0'</span></span><br><span class=\"line\"></span><br><span class=\"line\">target <span class=\"string\">'App'</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\"># 编译动态库（swift必须）</span></span><br><span class=\"line\">  use_frameworks!</span><br><span class=\"line\">  </span><br><span class=\"line\">  pod <span class=\"string\">'AFNetworking'</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  pod <span class=\"string\">'SVProgressHUD'</span>, <span class=\"string\">'~&gt;2.1'</span> <span class=\"comment\">#大于等于2.1，小于2.2</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  pod <span class=\"string\">'MJRefresh'</span>，<span class=\"symbol\">:git=&gt;</span> <span class=\"string\">'https://github.com/XXX/MJRefresh.git'</span> <span class=\"comment\">#从 https://github.com/XXX/MJRefresh.git 目录更新cocoapods</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  pod <span class=\"string\">'Masonry'</span>, <span class=\"symbol\">:git=&gt;</span> <span class=\"string\">'https://github.com/XXX/MJRefresh.git'</span>, <span class=\"symbol\">:branch</span> =&gt; <span class=\"string\">'1-1-stable'</span> <span class=\"comment\">#指定从特定的git repo branch更新cocoapod</span></span><br><span class=\"line\">  pod <span class=\"string\">'Masonry'</span>, <span class=\"symbol\">:git=&gt;</span> <span class=\"string\">'https://github.com/XXX/MJRefresh.git'</span>, <span class=\"symbol\">:tag</span> =&gt; <span class=\"string\">'1.3.0'</span> <span class=\"comment\">#指定从特定的git repo tag更新cocoapod</span></span><br><span class=\"line\"></span><br><span class=\"line\">  target <span class=\"string\">'AppTests'</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 编译动态库（swift必须）</span></span><br><span class=\"line\">    use_frameworks!</span><br><span class=\"line\">    </span><br><span class=\"line\">    pod <span class=\"string\">'FBSnapshotTestCase'</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"命令行-pod-install-和-pod-update\"><a href=\"#命令行-pod-install-和-pod-update\" class=\"headerlink\" title=\"命令行 pod install 和 pod update\"></a>命令行 <code>pod install</code> 和 <code>pod update</code></h3><ol>\n<li>参数 <code>--no-repo-update</code></li>\n</ol>\n<p>在执行<code>pod install</code>和<code>pod update</code>两条命令时，会执行<code>pod repo update</code>的操作，只更新当前项目的第三方框架。</p>\n<ol start=\"2\">\n<li>参数<code>—verbose</code> 和 <code>--silent</code></li>\n</ol>\n<p>用来控制<code>pod</code>命令，不希望看到输出的情况时可使用<code>--silent</code>。如果出错，可添加<code>--verbose</code>显示具体的出错信息。对于大多数的<code>Cocoapods</code>的命令行来说都带有着两个参数。</p>\n<h3 id=\"更新Ruby\"><a href=\"#更新Ruby\" class=\"headerlink\" title=\"更新Ruby\"></a>更新Ruby</h3><ol>\n<li><p>移除Ruby的默认源：</p>\n<p><code>gem sources --remove https://rubygems.org/</code> </p>\n</li>\n<li><p>替换Ruby China源：</p>\n<p><code>gem sources -a https://gems.ruby-china.org/</code> </p>\n</li>\n<li><p>验证当前的Ruby源：</p>\n<p><code>gem sources -l</code> </p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p><img src=\"/assets/blogImg/cocoapods-top.jpg\" alt=\"top\"></p>\n<blockquote>\n<p>文章内容摘自<a href=\"http://www.pluto-y.com/cocoapods-getting-stared/\" target=\"_blank\" rel=\"noopener\">pluto-y大神</a>的博客，感谢大神～</p>\n</blockquote>\n<h3 id=\"Podfile文件\"><a href=\"#Podfile文件\" class=\"headerlink\" title=\"Podfile文件\"></a>Podfile文件</h3>","more":"<h5 id=\"1-pod-‘框架名’-参数\"><a href=\"#1-pod-‘框架名’-参数\" class=\"headerlink\" title=\"1. pod ‘框架名’ 参数\"></a>1. pod ‘框架名’ 参数</h5><ul>\n<li><strong>参数一：版本号。</strong>有大于( <code>pod &#39;AFNetworking&#39;, &#39;&gt; 3.1&#39;</code> )、小于( <code>pod &#39;AFNetworking&#39;, &#39;&lt; 3.1&#39;</code> )、等于( <code>pod &#39;AFNetworking&#39;, &#39;3.1&#39;</code> )、大于等于( <code>pod &#39;AFNetworking&#39;, &#39;&gt;= 3.1&#39;</code> )等。<strong>‘~&gt; 3.1’ 意思是&gt;=3.1 并且&lt;3.2的意思。</strong></li>\n<li><strong>参数二：地址。</strong>地址Cocoapods可以指定某一个git的目录或者是本地的目录，表示一直用最新版本。例如直接在后面接上：<code>:git =&gt; &#39;https://github.com/XXX/AFNetworking.git&#39;</code>，或者开发模式下：<code>:path =&gt; &#39;~/Documents/AFNetworking&#39;</code>。</li>\n<li><strong>参数三：tag、branch、commit。</strong>例如：<code>:branch =&gt; &#39;branch名&#39;</code>、<code>:tag =&gt; &#39;tag名&#39;</code>、<code>:commit =&gt; &#39;提交号&#39;</code>。</li>\n<li><strong>参数四：inhibitallwarnings。</strong>用来避免第三方框架中带来的warnings。例如：<code>:inhibitallwarnings =&gt; true</code></li>\n</ul>\n<h5 id=\"2-platform\"><a href=\"#2-platform\" class=\"headerlink\" title=\"2. platform\"></a>2. platform</h5><p>依赖的库希望在哪个平台被编译。 <code>platform :ios, &#39;7.0&#39;</code> 希望采用iOS7.0进行编译。</p>\n<ol>\n<li><p>target</p>\n<p>指定具体的配置适配在哪个<strong>target</strong>。</p>\n</li>\n<li><p>use_frameworks!</p>\n<p>指明编译成动态库。<strong>swift下必须有这句话。</strong></p>\n</li>\n<li><p>source</p>\n<p>指明Cocoapods从哪些仓库中获得框架的源代码。</p>\n</li>\n</ol>\n<h4 id=\"Demo：\"><a href=\"#Demo：\" class=\"headerlink\" title=\"Demo：\"></a>Demo：</h4><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># open source</span></span><br><span class=\"line\">source <span class=\"string\">'https://github.com/CocoaPods/Specs.git'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 私有源</span></span><br><span class=\"line\">source <span class=\"string\">'https://github.com/Artsy/Specs.git'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定 iOS9.0 进行编译</span></span><br><span class=\"line\">platform <span class=\"symbol\">:ios</span>, <span class=\"string\">'9.0'</span></span><br><span class=\"line\"></span><br><span class=\"line\">target <span class=\"string\">'App'</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\"># 编译动态库（swift必须）</span></span><br><span class=\"line\">  use_frameworks!</span><br><span class=\"line\">  </span><br><span class=\"line\">  pod <span class=\"string\">'AFNetworking'</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  pod <span class=\"string\">'SVProgressHUD'</span>, <span class=\"string\">'~&gt;2.1'</span> <span class=\"comment\">#大于等于2.1，小于2.2</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  pod <span class=\"string\">'MJRefresh'</span>，<span class=\"symbol\">:git=&gt;</span> <span class=\"string\">'https://github.com/XXX/MJRefresh.git'</span> <span class=\"comment\">#从 https://github.com/XXX/MJRefresh.git 目录更新cocoapods</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  pod <span class=\"string\">'Masonry'</span>, <span class=\"symbol\">:git=&gt;</span> <span class=\"string\">'https://github.com/XXX/MJRefresh.git'</span>, <span class=\"symbol\">:branch</span> =&gt; <span class=\"string\">'1-1-stable'</span> <span class=\"comment\">#指定从特定的git repo branch更新cocoapod</span></span><br><span class=\"line\">  pod <span class=\"string\">'Masonry'</span>, <span class=\"symbol\">:git=&gt;</span> <span class=\"string\">'https://github.com/XXX/MJRefresh.git'</span>, <span class=\"symbol\">:tag</span> =&gt; <span class=\"string\">'1.3.0'</span> <span class=\"comment\">#指定从特定的git repo tag更新cocoapod</span></span><br><span class=\"line\"></span><br><span class=\"line\">  target <span class=\"string\">'AppTests'</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 编译动态库（swift必须）</span></span><br><span class=\"line\">    use_frameworks!</span><br><span class=\"line\">    </span><br><span class=\"line\">    pod <span class=\"string\">'FBSnapshotTestCase'</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"命令行-pod-install-和-pod-update\"><a href=\"#命令行-pod-install-和-pod-update\" class=\"headerlink\" title=\"命令行 pod install 和 pod update\"></a>命令行 <code>pod install</code> 和 <code>pod update</code></h3><ol>\n<li>参数 <code>--no-repo-update</code></li>\n</ol>\n<p>在执行<code>pod install</code>和<code>pod update</code>两条命令时，会执行<code>pod repo update</code>的操作，只更新当前项目的第三方框架。</p>\n<ol start=\"2\">\n<li>参数<code>—verbose</code> 和 <code>--silent</code></li>\n</ol>\n<p>用来控制<code>pod</code>命令，不希望看到输出的情况时可使用<code>--silent</code>。如果出错，可添加<code>--verbose</code>显示具体的出错信息。对于大多数的<code>Cocoapods</code>的命令行来说都带有着两个参数。</p>\n<h3 id=\"更新Ruby\"><a href=\"#更新Ruby\" class=\"headerlink\" title=\"更新Ruby\"></a>更新Ruby</h3><ol>\n<li><p>移除Ruby的默认源：</p>\n<p><code>gem sources --remove https://rubygems.org/</code> </p>\n</li>\n<li><p>替换Ruby China源：</p>\n<p><code>gem sources -a https://gems.ruby-china.org/</code> </p>\n</li>\n<li><p>验证当前的Ruby源：</p>\n<p><code>gem sources -l</code> </p>\n</li>\n</ol>"},{"layout":"post","title":"我遇到的一些面试题","date":"2018-04-14T02:36:00.000Z","comments":0,"toc":true,"_content":"![top](/assets/blogImg/interview-top.jpg)\n\n<!-- more -->\n\n### 1. 一个objc对象的isa的指针指向什么？\n\nisa指针指向它的类对象，类对象的isa指针指向该类对象元对象(meta class)，元对象的isa指针指向根元对象，根元对象的isa指针指向自身。\n\n> **类对象：**当向一个class发送消息时，class本身是一个对象，未编译时是一个结构体。\n\n### 2. 类对象的superclass指针指向什么？ \n\n类对象的superclass指针指向它的父类对象，如果该类为根类（NSObject），则指向nil。\n\n### 3. 一个由C/C++编译的程序占用的内存（内存分配方式）有哪几种？\n\n- **堆区（heap）：**由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收。堆空间饿分配总是动态的，地址由低向高增长。\n\n- **栈区（stack）：**由编译器自动分配释放。栈空间分静态分配和动态分配两种，静态分配由编译器完成，动态分配由alloca函数分配（自动释放）,地址由高向低增长。\n- **静态区（全局区）（static）：**全局变量和静态变量的存储放在一起的，初始化的全局变量和静态变量是放在一块内存区域，未初始化的全局变量和静态变量放在相邻的另一块内存区域。程序结束后由系统自动释放。\n- **常量区：**由系统自动释放。\n- **代码区：**存放函数的二进制代码，只准许读取，不允许写入。\n\n### 4.  如何用GCD同步若干个异步调用？\n\n使用dispatch_group_enter和dispatch_group_level处理异步任务的同步。\n\n```objective-c\ndispatch_queue_t queue = dispatch_queue_create(\"com.queue.demo\", DISPATCH_QUEUE_CONCURRENT);\ndispatch_group_t group = dispatch_group_create();\n\ndispatch_group_async(group, queue, ^{\n    /*模拟异步耗时操作 */\n    dispatch_group_enter(group);\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        sleep(3);\n        NSLog(@\"任务1\");\n        dispatch_group_leave(group);\n    });\n});\ndispatch_group_async(group, queue, ^{\n    /*模拟异步耗时操作 */\n    dispatch_group_enter(group);\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        sleep(1);\n        NSLog(@\"任务2\");\n        dispatch_group_leave(group);\n    });\n});\ndispatch_group_async(group, queue, ^{\n    /*模拟异步耗时操作 */\n    dispatch_group_enter(group);\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        sleep(2);\n        NSLog(@\"任务3\");\n        dispatch_group_leave(group);\n    });\n});\ndispatch_group_notify(group, dispatch_get_main_queue(), ^{\n    // 任务完成\n    NSLog(@\"任务完成\");\n});\n```\n\n### 5. 并发与并行的概念\n\n并发指能够让多个任务在逻辑上同时执行的程序设计，而并行则是指在物理上真正的同时执行。并行是并发的子集，属于并发的一种实现方式。通过时间片轮转实现的多任务同时执行是通过调度算法实现逻辑上的同步执行，属于并发。通过多核 CPU 实现并发时，多任务是真正物理上的同时执行，才属于并行。\n\n> [iOS中的多线程技术](http://xuyafei.cn/post/draft/ios-thread)\n\n### 6.集合对象的深复制实现方式 \n\n- 第一种方法：通过归解档生成两份完全独立的对象，但是前提是对象必须支持 NSCoding 协议。\n- 第二种方法：使用`initWithSet:copyItems:`第二个参数为`YES`实现深复制，集合里的每个对象都会收到 `copyWithZone:` 消息。如果集合里的对象遵循 `NSCopying` 协议，那么对象就会被深复制到新的集合。\n\n> [iOS 集合的深复制与浅复制](https://www.zybuluo.com/MicroCai/note/50592)\n\n### 7. `@autoreleasepool`如何实现的？释放时机是什么？ \n\n- 对 autorelease 分别执行 push和 pop 操作。销毁对象时执行release操作。\n- 在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的`runloop`迭代结束时释放的，而它能够释放的原因是**系统在每个runloop迭代中都加入了自动释放池Push和Pop**\n\n> [黑幕背后的Autorelease](https://blog.sunnyxx.com/2014/10/15/behind-autorelease/)\n\n### 8. iOS事件是如何响应的？\n\niOS获取到了用户的“点击”这一行为后，把这个事件封装成UITouch和UIEvent形式的实例，然后找到当前运行的程序，并逐级寻找能够响应这个事件的对象，直到没有响应者响应。这个过程就叫做事件的响应链。\n\n> 示例：`UIButton` -> `UIView` -> `UIViewController` -> `UIWindow` -> `UIApplication` -> `AppDelegate`\n\n### 9. 数组和链表的区别？\n\n- 数组静态分配内存，链表动态分配内存。\n- 数组在内存中连续，链表不连续。\n- 数组元素在栈区，链表元素在堆区。\n- 数组元素利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度为O(n)。\n- 数组插入或删除元素的时间复杂度为O(n)，链表的时间复杂度为O(1)。\n\n","source":"_posts/InterviewQuestions-20180414.md","raw":"---\nlayout: post\ntitle: \"我遇到的一些面试题\"\ndate: 2018-04-014 10:36\ncomments: false\ntoc: true\ntags: \n\n\t- 面试\n---\n![top](/assets/blogImg/interview-top.jpg)\n\n<!-- more -->\n\n### 1. 一个objc对象的isa的指针指向什么？\n\nisa指针指向它的类对象，类对象的isa指针指向该类对象元对象(meta class)，元对象的isa指针指向根元对象，根元对象的isa指针指向自身。\n\n> **类对象：**当向一个class发送消息时，class本身是一个对象，未编译时是一个结构体。\n\n### 2. 类对象的superclass指针指向什么？ \n\n类对象的superclass指针指向它的父类对象，如果该类为根类（NSObject），则指向nil。\n\n### 3. 一个由C/C++编译的程序占用的内存（内存分配方式）有哪几种？\n\n- **堆区（heap）：**由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收。堆空间饿分配总是动态的，地址由低向高增长。\n\n- **栈区（stack）：**由编译器自动分配释放。栈空间分静态分配和动态分配两种，静态分配由编译器完成，动态分配由alloca函数分配（自动释放）,地址由高向低增长。\n- **静态区（全局区）（static）：**全局变量和静态变量的存储放在一起的，初始化的全局变量和静态变量是放在一块内存区域，未初始化的全局变量和静态变量放在相邻的另一块内存区域。程序结束后由系统自动释放。\n- **常量区：**由系统自动释放。\n- **代码区：**存放函数的二进制代码，只准许读取，不允许写入。\n\n### 4.  如何用GCD同步若干个异步调用？\n\n使用dispatch_group_enter和dispatch_group_level处理异步任务的同步。\n\n```objective-c\ndispatch_queue_t queue = dispatch_queue_create(\"com.queue.demo\", DISPATCH_QUEUE_CONCURRENT);\ndispatch_group_t group = dispatch_group_create();\n\ndispatch_group_async(group, queue, ^{\n    /*模拟异步耗时操作 */\n    dispatch_group_enter(group);\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        sleep(3);\n        NSLog(@\"任务1\");\n        dispatch_group_leave(group);\n    });\n});\ndispatch_group_async(group, queue, ^{\n    /*模拟异步耗时操作 */\n    dispatch_group_enter(group);\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        sleep(1);\n        NSLog(@\"任务2\");\n        dispatch_group_leave(group);\n    });\n});\ndispatch_group_async(group, queue, ^{\n    /*模拟异步耗时操作 */\n    dispatch_group_enter(group);\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        sleep(2);\n        NSLog(@\"任务3\");\n        dispatch_group_leave(group);\n    });\n});\ndispatch_group_notify(group, dispatch_get_main_queue(), ^{\n    // 任务完成\n    NSLog(@\"任务完成\");\n});\n```\n\n### 5. 并发与并行的概念\n\n并发指能够让多个任务在逻辑上同时执行的程序设计，而并行则是指在物理上真正的同时执行。并行是并发的子集，属于并发的一种实现方式。通过时间片轮转实现的多任务同时执行是通过调度算法实现逻辑上的同步执行，属于并发。通过多核 CPU 实现并发时，多任务是真正物理上的同时执行，才属于并行。\n\n> [iOS中的多线程技术](http://xuyafei.cn/post/draft/ios-thread)\n\n### 6.集合对象的深复制实现方式 \n\n- 第一种方法：通过归解档生成两份完全独立的对象，但是前提是对象必须支持 NSCoding 协议。\n- 第二种方法：使用`initWithSet:copyItems:`第二个参数为`YES`实现深复制，集合里的每个对象都会收到 `copyWithZone:` 消息。如果集合里的对象遵循 `NSCopying` 协议，那么对象就会被深复制到新的集合。\n\n> [iOS 集合的深复制与浅复制](https://www.zybuluo.com/MicroCai/note/50592)\n\n### 7. `@autoreleasepool`如何实现的？释放时机是什么？ \n\n- 对 autorelease 分别执行 push和 pop 操作。销毁对象时执行release操作。\n- 在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的`runloop`迭代结束时释放的，而它能够释放的原因是**系统在每个runloop迭代中都加入了自动释放池Push和Pop**\n\n> [黑幕背后的Autorelease](https://blog.sunnyxx.com/2014/10/15/behind-autorelease/)\n\n### 8. iOS事件是如何响应的？\n\niOS获取到了用户的“点击”这一行为后，把这个事件封装成UITouch和UIEvent形式的实例，然后找到当前运行的程序，并逐级寻找能够响应这个事件的对象，直到没有响应者响应。这个过程就叫做事件的响应链。\n\n> 示例：`UIButton` -> `UIView` -> `UIViewController` -> `UIWindow` -> `UIApplication` -> `AppDelegate`\n\n### 9. 数组和链表的区别？\n\n- 数组静态分配内存，链表动态分配内存。\n- 数组在内存中连续，链表不连续。\n- 数组元素在栈区，链表元素在堆区。\n- 数组元素利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度为O(n)。\n- 数组插入或删除元素的时间复杂度为O(n)，链表的时间复杂度为O(1)。\n\n","slug":"InterviewQuestions-20180414","published":1,"updated":"2018-04-19T09:06:05.298Z","photos":[],"link":"","_id":"cjg6c1dxz0001gzxfpldpnl8o","content":"<p><img src=\"/assets/blogImg/interview-top.jpg\" alt=\"top\"></p>\n<a id=\"more\"></a>\n<h3 id=\"1-一个objc对象的isa的指针指向什么？\"><a href=\"#1-一个objc对象的isa的指针指向什么？\" class=\"headerlink\" title=\"1. 一个objc对象的isa的指针指向什么？\"></a>1. 一个objc对象的isa的指针指向什么？</h3><p>isa指针指向它的类对象，类对象的isa指针指向该类对象元对象(meta class)，元对象的isa指针指向根元对象，根元对象的isa指针指向自身。</p>\n<blockquote>\n<p><strong>类对象：</strong>当向一个class发送消息时，class本身是一个对象，未编译时是一个结构体。</p>\n</blockquote>\n<h3 id=\"2-类对象的superclass指针指向什么？\"><a href=\"#2-类对象的superclass指针指向什么？\" class=\"headerlink\" title=\"2. 类对象的superclass指针指向什么？\"></a>2. 类对象的superclass指针指向什么？</h3><p>类对象的superclass指针指向它的父类对象，如果该类为根类（NSObject），则指向nil。</p>\n<h3 id=\"3-一个由C-C-编译的程序占用的内存（内存分配方式）有哪几种？\"><a href=\"#3-一个由C-C-编译的程序占用的内存（内存分配方式）有哪几种？\" class=\"headerlink\" title=\"3. 一个由C/C++编译的程序占用的内存（内存分配方式）有哪几种？\"></a>3. 一个由C/C++编译的程序占用的内存（内存分配方式）有哪几种？</h3><ul>\n<li><p><strong>堆区（heap）：</strong>由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收。堆空间饿分配总是动态的，地址由低向高增长。</p>\n</li>\n<li><p><strong>栈区（stack）：</strong>由编译器自动分配释放。栈空间分静态分配和动态分配两种，静态分配由编译器完成，动态分配由alloca函数分配（自动释放）,地址由高向低增长。</p>\n</li>\n<li><strong>静态区（全局区）（static）：</strong>全局变量和静态变量的存储放在一起的，初始化的全局变量和静态变量是放在一块内存区域，未初始化的全局变量和静态变量放在相邻的另一块内存区域。程序结束后由系统自动释放。</li>\n<li><strong>常量区：</strong>由系统自动释放。</li>\n<li><strong>代码区：</strong>存放函数的二进制代码，只准许读取，不允许写入。</li>\n</ul>\n<h3 id=\"4-如何用GCD同步若干个异步调用？\"><a href=\"#4-如何用GCD同步若干个异步调用？\" class=\"headerlink\" title=\"4.  如何用GCD同步若干个异步调用？\"></a>4.  如何用GCD同步若干个异步调用？</h3><p>使用dispatch_group_enter和dispatch_group_level处理异步任务的同步。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;com.queue.demo&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\">dispatch_group_t group = dispatch_group_create();</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">    /*模拟异步耗时操作 */</span><br><span class=\"line\">    dispatch_group_enter(group);</span><br><span class=\"line\">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\">        sleep(3);</span><br><span class=\"line\">        NSLog(@&quot;任务1&quot;);</span><br><span class=\"line\">        dispatch_group_leave(group);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">    /*模拟异步耗时操作 */</span><br><span class=\"line\">    dispatch_group_enter(group);</span><br><span class=\"line\">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\">        sleep(1);</span><br><span class=\"line\">        NSLog(@&quot;任务2&quot;);</span><br><span class=\"line\">        dispatch_group_leave(group);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">    /*模拟异步耗时操作 */</span><br><span class=\"line\">    dispatch_group_enter(group);</span><br><span class=\"line\">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\">        sleep(2);</span><br><span class=\"line\">        NSLog(@&quot;任务3&quot;);</span><br><span class=\"line\">        dispatch_group_leave(group);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    // 任务完成</span><br><span class=\"line\">    NSLog(@&quot;任务完成&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-并发与并行的概念\"><a href=\"#5-并发与并行的概念\" class=\"headerlink\" title=\"5. 并发与并行的概念\"></a>5. 并发与并行的概念</h3><p>并发指能够让多个任务在逻辑上同时执行的程序设计，而并行则是指在物理上真正的同时执行。并行是并发的子集，属于并发的一种实现方式。通过时间片轮转实现的多任务同时执行是通过调度算法实现逻辑上的同步执行，属于并发。通过多核 CPU 实现并发时，多任务是真正物理上的同时执行，才属于并行。</p>\n<blockquote>\n<p><a href=\"http://xuyafei.cn/post/draft/ios-thread\" target=\"_blank\" rel=\"noopener\">iOS中的多线程技术</a></p>\n</blockquote>\n<h3 id=\"6-集合对象的深复制实现方式\"><a href=\"#6-集合对象的深复制实现方式\" class=\"headerlink\" title=\"6.集合对象的深复制实现方式\"></a>6.集合对象的深复制实现方式</h3><ul>\n<li>第一种方法：通过归解档生成两份完全独立的对象，但是前提是对象必须支持 NSCoding 协议。</li>\n<li>第二种方法：使用<code>initWithSet:copyItems:</code>第二个参数为<code>YES</code>实现深复制，集合里的每个对象都会收到 <code>copyWithZone:</code> 消息。如果集合里的对象遵循 <code>NSCopying</code> 协议，那么对象就会被深复制到新的集合。</li>\n</ul>\n<blockquote>\n<p><a href=\"https://www.zybuluo.com/MicroCai/note/50592\" target=\"_blank\" rel=\"noopener\">iOS 集合的深复制与浅复制</a></p>\n</blockquote>\n<h3 id=\"7-autoreleasepool如何实现的？释放时机是什么？\"><a href=\"#7-autoreleasepool如何实现的？释放时机是什么？\" class=\"headerlink\" title=\"7. @autoreleasepool如何实现的？释放时机是什么？\"></a>7. <code>@autoreleasepool</code>如何实现的？释放时机是什么？</h3><ul>\n<li>对 autorelease 分别执行 push和 pop 操作。销毁对象时执行release操作。</li>\n<li>在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的<code>runloop</code>迭代结束时释放的，而它能够释放的原因是<strong>系统在每个runloop迭代中都加入了自动释放池Push和Pop</strong></li>\n</ul>\n<blockquote>\n<p><a href=\"https://blog.sunnyxx.com/2014/10/15/behind-autorelease/\" target=\"_blank\" rel=\"noopener\">黑幕背后的Autorelease</a></p>\n</blockquote>\n<h3 id=\"8-iOS事件是如何响应的？\"><a href=\"#8-iOS事件是如何响应的？\" class=\"headerlink\" title=\"8. iOS事件是如何响应的？\"></a>8. iOS事件是如何响应的？</h3><p>iOS获取到了用户的“点击”这一行为后，把这个事件封装成UITouch和UIEvent形式的实例，然后找到当前运行的程序，并逐级寻找能够响应这个事件的对象，直到没有响应者响应。这个过程就叫做事件的响应链。</p>\n<blockquote>\n<p>示例：<code>UIButton</code> -&gt; <code>UIView</code> -&gt; <code>UIViewController</code> -&gt; <code>UIWindow</code> -&gt; <code>UIApplication</code> -&gt; <code>AppDelegate</code></p>\n</blockquote>\n<h3 id=\"9-数组和链表的区别？\"><a href=\"#9-数组和链表的区别？\" class=\"headerlink\" title=\"9. 数组和链表的区别？\"></a>9. 数组和链表的区别？</h3><ul>\n<li>数组静态分配内存，链表动态分配内存。</li>\n<li>数组在内存中连续，链表不连续。</li>\n<li>数组元素在栈区，链表元素在堆区。</li>\n<li>数组元素利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度为O(n)。</li>\n<li>数组插入或删除元素的时间复杂度为O(n)，链表的时间复杂度为O(1)。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><img src=\"/assets/blogImg/interview-top.jpg\" alt=\"top\"></p>","more":"<h3 id=\"1-一个objc对象的isa的指针指向什么？\"><a href=\"#1-一个objc对象的isa的指针指向什么？\" class=\"headerlink\" title=\"1. 一个objc对象的isa的指针指向什么？\"></a>1. 一个objc对象的isa的指针指向什么？</h3><p>isa指针指向它的类对象，类对象的isa指针指向该类对象元对象(meta class)，元对象的isa指针指向根元对象，根元对象的isa指针指向自身。</p>\n<blockquote>\n<p><strong>类对象：</strong>当向一个class发送消息时，class本身是一个对象，未编译时是一个结构体。</p>\n</blockquote>\n<h3 id=\"2-类对象的superclass指针指向什么？\"><a href=\"#2-类对象的superclass指针指向什么？\" class=\"headerlink\" title=\"2. 类对象的superclass指针指向什么？\"></a>2. 类对象的superclass指针指向什么？</h3><p>类对象的superclass指针指向它的父类对象，如果该类为根类（NSObject），则指向nil。</p>\n<h3 id=\"3-一个由C-C-编译的程序占用的内存（内存分配方式）有哪几种？\"><a href=\"#3-一个由C-C-编译的程序占用的内存（内存分配方式）有哪几种？\" class=\"headerlink\" title=\"3. 一个由C/C++编译的程序占用的内存（内存分配方式）有哪几种？\"></a>3. 一个由C/C++编译的程序占用的内存（内存分配方式）有哪几种？</h3><ul>\n<li><p><strong>堆区（heap）：</strong>由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收。堆空间饿分配总是动态的，地址由低向高增长。</p>\n</li>\n<li><p><strong>栈区（stack）：</strong>由编译器自动分配释放。栈空间分静态分配和动态分配两种，静态分配由编译器完成，动态分配由alloca函数分配（自动释放）,地址由高向低增长。</p>\n</li>\n<li><strong>静态区（全局区）（static）：</strong>全局变量和静态变量的存储放在一起的，初始化的全局变量和静态变量是放在一块内存区域，未初始化的全局变量和静态变量放在相邻的另一块内存区域。程序结束后由系统自动释放。</li>\n<li><strong>常量区：</strong>由系统自动释放。</li>\n<li><strong>代码区：</strong>存放函数的二进制代码，只准许读取，不允许写入。</li>\n</ul>\n<h3 id=\"4-如何用GCD同步若干个异步调用？\"><a href=\"#4-如何用GCD同步若干个异步调用？\" class=\"headerlink\" title=\"4.  如何用GCD同步若干个异步调用？\"></a>4.  如何用GCD同步若干个异步调用？</h3><p>使用dispatch_group_enter和dispatch_group_level处理异步任务的同步。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;com.queue.demo&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\">dispatch_group_t group = dispatch_group_create();</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">    /*模拟异步耗时操作 */</span><br><span class=\"line\">    dispatch_group_enter(group);</span><br><span class=\"line\">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\">        sleep(3);</span><br><span class=\"line\">        NSLog(@&quot;任务1&quot;);</span><br><span class=\"line\">        dispatch_group_leave(group);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">    /*模拟异步耗时操作 */</span><br><span class=\"line\">    dispatch_group_enter(group);</span><br><span class=\"line\">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\">        sleep(1);</span><br><span class=\"line\">        NSLog(@&quot;任务2&quot;);</span><br><span class=\"line\">        dispatch_group_leave(group);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">    /*模拟异步耗时操作 */</span><br><span class=\"line\">    dispatch_group_enter(group);</span><br><span class=\"line\">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\">        sleep(2);</span><br><span class=\"line\">        NSLog(@&quot;任务3&quot;);</span><br><span class=\"line\">        dispatch_group_leave(group);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    // 任务完成</span><br><span class=\"line\">    NSLog(@&quot;任务完成&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-并发与并行的概念\"><a href=\"#5-并发与并行的概念\" class=\"headerlink\" title=\"5. 并发与并行的概念\"></a>5. 并发与并行的概念</h3><p>并发指能够让多个任务在逻辑上同时执行的程序设计，而并行则是指在物理上真正的同时执行。并行是并发的子集，属于并发的一种实现方式。通过时间片轮转实现的多任务同时执行是通过调度算法实现逻辑上的同步执行，属于并发。通过多核 CPU 实现并发时，多任务是真正物理上的同时执行，才属于并行。</p>\n<blockquote>\n<p><a href=\"http://xuyafei.cn/post/draft/ios-thread\" target=\"_blank\" rel=\"noopener\">iOS中的多线程技术</a></p>\n</blockquote>\n<h3 id=\"6-集合对象的深复制实现方式\"><a href=\"#6-集合对象的深复制实现方式\" class=\"headerlink\" title=\"6.集合对象的深复制实现方式\"></a>6.集合对象的深复制实现方式</h3><ul>\n<li>第一种方法：通过归解档生成两份完全独立的对象，但是前提是对象必须支持 NSCoding 协议。</li>\n<li>第二种方法：使用<code>initWithSet:copyItems:</code>第二个参数为<code>YES</code>实现深复制，集合里的每个对象都会收到 <code>copyWithZone:</code> 消息。如果集合里的对象遵循 <code>NSCopying</code> 协议，那么对象就会被深复制到新的集合。</li>\n</ul>\n<blockquote>\n<p><a href=\"https://www.zybuluo.com/MicroCai/note/50592\" target=\"_blank\" rel=\"noopener\">iOS 集合的深复制与浅复制</a></p>\n</blockquote>\n<h3 id=\"7-autoreleasepool如何实现的？释放时机是什么？\"><a href=\"#7-autoreleasepool如何实现的？释放时机是什么？\" class=\"headerlink\" title=\"7. @autoreleasepool如何实现的？释放时机是什么？\"></a>7. <code>@autoreleasepool</code>如何实现的？释放时机是什么？</h3><ul>\n<li>对 autorelease 分别执行 push和 pop 操作。销毁对象时执行release操作。</li>\n<li>在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的<code>runloop</code>迭代结束时释放的，而它能够释放的原因是<strong>系统在每个runloop迭代中都加入了自动释放池Push和Pop</strong></li>\n</ul>\n<blockquote>\n<p><a href=\"https://blog.sunnyxx.com/2014/10/15/behind-autorelease/\" target=\"_blank\" rel=\"noopener\">黑幕背后的Autorelease</a></p>\n</blockquote>\n<h3 id=\"8-iOS事件是如何响应的？\"><a href=\"#8-iOS事件是如何响应的？\" class=\"headerlink\" title=\"8. iOS事件是如何响应的？\"></a>8. iOS事件是如何响应的？</h3><p>iOS获取到了用户的“点击”这一行为后，把这个事件封装成UITouch和UIEvent形式的实例，然后找到当前运行的程序，并逐级寻找能够响应这个事件的对象，直到没有响应者响应。这个过程就叫做事件的响应链。</p>\n<blockquote>\n<p>示例：<code>UIButton</code> -&gt; <code>UIView</code> -&gt; <code>UIViewController</code> -&gt; <code>UIWindow</code> -&gt; <code>UIApplication</code> -&gt; <code>AppDelegate</code></p>\n</blockquote>\n<h3 id=\"9-数组和链表的区别？\"><a href=\"#9-数组和链表的区别？\" class=\"headerlink\" title=\"9. 数组和链表的区别？\"></a>9. 数组和链表的区别？</h3><ul>\n<li>数组静态分配内存，链表动态分配内存。</li>\n<li>数组在内存中连续，链表不连续。</li>\n<li>数组元素在栈区，链表元素在堆区。</li>\n<li>数组元素利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度为O(n)。</li>\n<li>数组插入或删除元素的时间复杂度为O(n)，链表的时间复杂度为O(1)。</li>\n</ul>"},{"title":"HTTP和HTTPS对比","date":"2018-04-08T09:16:26.000Z","_content":"\n![top](/assets/blogImg/http-https-top.jpg)\n\n<!-- more -->\n\n> **HTTP协议（HyperText Transfer Protocol，超文本传输协议）**：是一种用于分布式、协作式和超媒体信息系统的应用层协议。目的是为了提供一种发布和接收HTML页面的方法。默认端口号为`80`。\n>\n> **HTTPS协议（Hypertext Transfer Protocol Secure）**：是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。默认端口号为`443`。\n>\n> > 引自维基百科[HTTP](https://zh.wikipedia.org/wiki/超文本传输协议)和[HTTPS](https://zh.wikipedia.org/wiki/超文本传输安全协议)\n\n## HTTP\n\n#### 1. 协议概述\n\n​\t由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如\"HTTP/1.1 200 OK\"，以及返回的内容，如请求的文件、错误消息、或者其它信息。\n\n#### 2. URL\n\n> **URL（Uniform / Universal Resource Locator）**：统一资源定位符，是用于完整地描述Internet上网页和其他资源的地址的一种标识方法。\n\n**基本格式**：`scheme://host[:port#]/path/…/[?query-string][#anchor]`\n\n- **scheme**：协议(例如：http, https, ftp)\n- **host**：服务器的IP地址或者域名\n- **port**#：服务器的端口（如果是走协议默认端口，缺省端口80）\n- **path**：访问资源的路径\n- **query-string**：参数，发送给http服务器的数据\n- **anchor**：锚（跳转到网页的指定锚点位置）\n\n#### 3. 请求方法（HTTP/1.1）\n\n1. **GET**：请求指定的页面信息，并返回实体主体。参数显示在URL中。\n2. **HEAD**：类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头。\n3. **POST**：向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。参数在请求体中。\n4. **PUT**：从客户端向服务器传达的数据取代指定的文档的内容。\n5. **DELETE**：请求服务器删除指定的页面。\n6. **CONNECT**：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n7. **OPTIONS**：允许客户端查看服务器的性能。\n8. **TRACE**：回显服务器收到的请求，主要用于测试或诊断。\n\n> 避免使用`GET`方式提交表单，因为有可能会导致安全问题。比如说在登陆表单中用Get方式，用户输入的用户名和密码将在地址栏中暴露无遗。\n\n#### 4.常用的请求报头\n\n> HTTP请求由四个部分组成，分别是：**请求行**、**请求头部**、**空行**、**请求数据**。\n\n##### 1.Host（主机和端口号）\n\n> **Host**：对应网址URL中的Web名称和端口号，用于指定被请求资源的Internet主机和端口号，通常属于URL的一部分。\n\n##### 2.Connection (链接类型)\n\n> **Connection**：表示客户端与服务连接类型.\n\n1. Client 发起一个包含 `Connection:keep-alive` 的请求，HTTP/1.1使用 `keep-alive` 为默认值。\n2. Server收到请求后：\n   - 如果 Server 支持 `keep-alive`，回复一个包含 `Connection:keep-alive` 的响应，不关闭连接；\n   - 如果 Server 不支持 `keep-alive`，回复一个包含 `Connection:close` 的响应，关闭连接。\n3. 如果client收到包含 `Connection:keep-alive` 的响应，向同一个连接发送下一个请求，直到一方主动关闭连接。\n\n> `keep-alive`在很多情况下能够重用连接，减少资源消耗，缩短响应时间，比如当浏览器需要多个文件时(比如一个HTML文件和相关的图形文件)，不需要每次都去请求建立连接。\n\n##### 3.Upgrade-Insecure-Requests (升级为HTTPS请求)\n\n> **Upgrade-Insecure-Requests**：升级不安全的请求，意思是会在加载 http 资源时自动替换成 https 请求，让浏览器不再显示https页面中的http请求警报。\n\n##### 4.User-Agent(浏览器名称)\n\n> **User-Agent**：是客户浏览器的名称。\n\n##### 5.Accept（传输文件类型）\n\n> **Accept**：指浏览器或其他客户端可以接受的MIME（Multipurpose Internet Mail Extensions（多用途互联网邮件扩展））文件类型，服务器可以根据它判断并返回适当的文件格式。\n\n- `Accept: \\*/\\*`：表示什么都可以接收。\n- `Accept: image/gif`：表示客户端希望接收GIF图像格式的资源。\n- `Accept: text/html`：表示客户端希望接收html文本。\n- `Accept: text/html, application/xhtml+xml;q=0.9, image/*;q=0.8`：表示浏览器支持的MIME类型分别是html文本、xhtml和xml文档、所有的图像格式资源。\n\n> `q`是权重系数，范围0 =< q <= 1，`q`值越大，请求越倾向于获得其“`;`”之前的类型表示的内容。若没有指定`q`值，则默认为1，按照从左到右排序顺序；若被赋值为0，则用于表示浏览器不接收此内容类型。\n>\n> `Text`：用于标准化的表示的文本信息，文本消息可以是多种字符集和或者多种格式的。\n>\n> `Application`：用于传输应用程序数据或者二进制数据。\n\n##### 6.Referer（页面跳转处）\n\n> **Referer**：表明产生请求的网页来自于哪个URL，用户是从该 Referer页面访问到当前请求的页面。这个属性可以用来跟踪Web请求来自哪个页面，是从什么网站来的等。例如防盗链原理。\n\n##### 7.Accept-Encoding（文件编解码格式）\n\n> **Accept-Encoding**：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后先解码，然后再检查文件格式，许多情形下这可以减少大量的下载时间。\n\n- `Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0`：如果有多个Encoding同时匹配, 按照q值顺序排列，本例中按顺序支持 gzip, identity压缩编码，支持gzip的浏览器会返回经过gzip编码的HTML页面。 如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。\n\n##### 8.Accept-Language（语言种类）\n\n> **Accept-Langeuage**：指出浏览器可以接受的语言种类，如en或en-us指英语，zh或者zh-cn指中文，当服务器能够提供一种以上的语言版本时要用到。\n\n##### 9.Accept-Charset（字符编码）\n\n> **Accept-Charset**：指出浏览器可以接受的字符编码。\n\n- `Accept-Charset:iso-8859-1,gb2312,utf-8`：本例中支持`ISO8859-1`、`gb2312`、`utf-8`编码。如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。\n\n##### 10.Cookie\n\n> **Cookie**：浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。\n\n##### 11.Content-Type （POST数据类型）\n\n> **Content-Type**：POST请求里用来表示的内容类型。\n\n- `Content-Type = Text/XML; charset=gb2312`：指明该请求中的消息体中包含的是纯文本的`XML`类型的数据，字符编码采用`gb2312`。\n\n#### 5.服务端常用的响应报头\n\n> HTTP响应由四个部分组成，分别是： **状态行**、**消息报头**、**空行**、**响应正文**。\n\n##### 1.Cache-Control: must-revalidate, no-cache, private\n\n> 这个值告诉客户端，服务端不希望客户端缓存资源，在下次请求资源时，必须要重新请求服务器，不能从缓存中获取资源。\n\n- `Cache-Control`是响应头中很重要的信息，当客户端请求头中包含`Cache-Control: max-age = 0`请求，明确表示不会缓存服务器资源时，`Cache-Control`作为回应信息，通常会返回`no-cache`。\n- 当客户端在请求头中没有包含`Cache-Control`时，服务端往往会定不同的资源不同的缓存策略，比如说oschina在缓存图片资源的策略是`Cache-Control: max-age = 86400`，这个意思是，从当前时间开始，在86400秒的时间内，客户端可以直接从缓存中读取资源，而不需要向服务器请求。\n\n##### 2.Connection: keep-alive\n\n> 这个字段作为回应客户端的`Connection: keep-alive`，告诉客户端服务器的TCP连接也是一个长连接，客户端可以继续使用这个TCP连接发送HTTP请求。\n\n##### 3.Content-Encoding: gzip\n\n> 告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码。\n\n##### 4.Content-Type: text/html; charset = UTF-8\n\n> 告诉客户端，资源文件的类型和字符编码，客户端通过UTF-8对资源进行解码，然后对资源进行html解析。\n\n##### 5.Date: Sun, 21 Sep 2016 06:18:21 GMT\n\n> 服务端发送资源时的服务器时间。\n\n##### 6.Expires: Sun, 1 Jan 2000 01:00:00 GMT\n\n> 告诉客户端可以在这个时间前直接访问缓存。该值存在问题，客户端和服务器的时间不一定都是相同的，所有没有`Cache-Control: max-age = *` 准确。\n\n##### 7.Pragma: no-cache\n\n> 含义与`Cache-Control`相同\n\n##### 8.Server: Tengine/1.4.6\n\n> 服务器和相对应的版本，告诉客户端服务器的信息。\n\n##### 9.Transfer-Encoding: chunked\n\n> 告诉客户端，服务器发送的资源方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。\n\n##### 10.Vary: Accept-Encoding\n\n> 告诉缓存服务器，缓存压缩文件和非压缩文件两个版本。\n\n#### 6.响应状态码\n\n- `100～199`：表示服务器成功接收部分请求，要求客户端继续提交其余请求才能完成整个处理过程。\n- `200～299`：表示服务器成功接收请求并 已完成整个处理过程。常用`200`（OK请求成功）。\n- `300～399`：为完成请求，客户端需进一步细化请求。例如：请求的资源已经移动一个新地址，常用`302`（所请求的页面已经临时转移至新的URL）、`307`和`304`（使用缓存资源）。\n- `400～499`：客户端的请求有错误，常用`404`（服务器无法找到被请求的页面）、`403`（服务器拒绝访问，权限不够）。\n- `500～599`：服务端出现错误，常用`500`（请求未完成。服务器遇到不可预知的情况）。\n\n#### 7.Cookie和Session\n\n> 服务器和客户端的交互仅限于请求/响应过程，结束之后便断开，在下一次请求时，服务器会认为新的客户端。为了维护他们之间的连接，让服务器知道这是前一个用户发送的请求，必须在一个地方保存客户端的信息。\n\n- `Cooke`：通过在客户端记录的信息确定用户的身份。\n- `Session`：通过在服务端记录的信息确定用户的身份。\n\n## HTTPS\n\n> HTTPS = HTTP + SSL/TLS\n>\n> SSL：Secure Sockets Layer 安全套接层\n>\n> TLS：ransport Layer Security 安全传输层协议。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）\n\n##### 1.客户端发起HTTPS请求\n\n##### 2.服务端的配置\n\n> 采用HTTPS协议的服务器必须有一套数字证书，包含一对公钥和私钥。\n\n##### 3.传送证书\n\n> 该证书是公钥，包含证书的颁发机构、过期时间等等。\n\n##### 4.客户端解析证书\n\n> 由客户端的TLS完成，首先验证公钥是否有效，比如颁发机构、过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密。\n\n##### 5.传送加密信息\n\n> 传送的是用证书加密后的随机值，目的是让服务端得到这个随机值，以后客户端和服务端通信就可以通过这个随机值来进行加密解密了。\n\n##### 6.服务端解密信息\n\n> 服务端用私钥解密后，得到了客户端传过来的随机值（私钥），然后把内容通过该值进行对称加密。\n\n##### 7.传输加密后的信息\n\n##### 8.客户端解密信息\n\n> 客户端用之前生成的私钥解密服务端传过来的信息，于是获取了解密后的内容。\n\n![RSA密钥交换过程](./images/HTTP和HTTPS.JPG)\n\n## 不同点\n\n- HTTP协议是运行在TCP之上，所有传输的内容都是明文，客户端和服务端都无法验证对方的身份。\n- HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS是运行在TCP之上。所有传输的内容都是经过加密，加密采用对称加密，但对称加密的密钥用服务器的证书进行了非对称加密。\n\n## TCP建立连接的三次握手\n\n> **FLAGS字段：**\n>\n> SYN：表示建立连接。\n>\n> FIN：表示关闭连接。\n>\n> ACK：表示响应。\n>\n> PSH：表示有DATA数据传输。\n>\n> RST：表示连接重置。\n\n- 第一次握手：主机A发送位码为syn＝1，随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机。\n- 第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包。\n- 第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。\n\n完成三次握手，主机A与主机B开始传送数据。\n\n## TCP断开连接的四次握手\n\n> TCP断开连接有两种方式，第一种是正常的四次握手断开的，第二种是RST异常断开的\n\n##### 1.正常断开\n\n- 服务器80端口向41826端口发出FIN的断开连接请求。\n- 41826端口收到请求之后向服务器80端口回复了一个ACK。\n- 41826端口向服务器80端口发送断开请求FIN。\n- 服务器80向客户端发送断开的回复ACK。\n\n##### 2.异常断开\n\n- 服务器80端口向41826端口发出FIN的断开连接请求。\n- 41826端口收到请求之后向服务器80端口回复了一个ACK。\n- 41826端口向服务器80端口发送了GET请求。\n- 41826端口向服务器80端口发送断开请求FIN。\n- 服务器端口80因为原因没有确认客户端发送的确认请求而断开，因此返回了RST。","source":"_posts/HTTP-and-HTTPS.md","raw":"---\ntitle: HTTP和HTTPS对比\ndate: 2018-04-8 17:16:26\ntags:\n- HTTP\n- HTTPS\n- 握手\n---\n\n![top](/assets/blogImg/http-https-top.jpg)\n\n<!-- more -->\n\n> **HTTP协议（HyperText Transfer Protocol，超文本传输协议）**：是一种用于分布式、协作式和超媒体信息系统的应用层协议。目的是为了提供一种发布和接收HTML页面的方法。默认端口号为`80`。\n>\n> **HTTPS协议（Hypertext Transfer Protocol Secure）**：是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。默认端口号为`443`。\n>\n> > 引自维基百科[HTTP](https://zh.wikipedia.org/wiki/超文本传输协议)和[HTTPS](https://zh.wikipedia.org/wiki/超文本传输安全协议)\n\n## HTTP\n\n#### 1. 协议概述\n\n​\t由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如\"HTTP/1.1 200 OK\"，以及返回的内容，如请求的文件、错误消息、或者其它信息。\n\n#### 2. URL\n\n> **URL（Uniform / Universal Resource Locator）**：统一资源定位符，是用于完整地描述Internet上网页和其他资源的地址的一种标识方法。\n\n**基本格式**：`scheme://host[:port#]/path/…/[?query-string][#anchor]`\n\n- **scheme**：协议(例如：http, https, ftp)\n- **host**：服务器的IP地址或者域名\n- **port**#：服务器的端口（如果是走协议默认端口，缺省端口80）\n- **path**：访问资源的路径\n- **query-string**：参数，发送给http服务器的数据\n- **anchor**：锚（跳转到网页的指定锚点位置）\n\n#### 3. 请求方法（HTTP/1.1）\n\n1. **GET**：请求指定的页面信息，并返回实体主体。参数显示在URL中。\n2. **HEAD**：类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头。\n3. **POST**：向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。参数在请求体中。\n4. **PUT**：从客户端向服务器传达的数据取代指定的文档的内容。\n5. **DELETE**：请求服务器删除指定的页面。\n6. **CONNECT**：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n7. **OPTIONS**：允许客户端查看服务器的性能。\n8. **TRACE**：回显服务器收到的请求，主要用于测试或诊断。\n\n> 避免使用`GET`方式提交表单，因为有可能会导致安全问题。比如说在登陆表单中用Get方式，用户输入的用户名和密码将在地址栏中暴露无遗。\n\n#### 4.常用的请求报头\n\n> HTTP请求由四个部分组成，分别是：**请求行**、**请求头部**、**空行**、**请求数据**。\n\n##### 1.Host（主机和端口号）\n\n> **Host**：对应网址URL中的Web名称和端口号，用于指定被请求资源的Internet主机和端口号，通常属于URL的一部分。\n\n##### 2.Connection (链接类型)\n\n> **Connection**：表示客户端与服务连接类型.\n\n1. Client 发起一个包含 `Connection:keep-alive` 的请求，HTTP/1.1使用 `keep-alive` 为默认值。\n2. Server收到请求后：\n   - 如果 Server 支持 `keep-alive`，回复一个包含 `Connection:keep-alive` 的响应，不关闭连接；\n   - 如果 Server 不支持 `keep-alive`，回复一个包含 `Connection:close` 的响应，关闭连接。\n3. 如果client收到包含 `Connection:keep-alive` 的响应，向同一个连接发送下一个请求，直到一方主动关闭连接。\n\n> `keep-alive`在很多情况下能够重用连接，减少资源消耗，缩短响应时间，比如当浏览器需要多个文件时(比如一个HTML文件和相关的图形文件)，不需要每次都去请求建立连接。\n\n##### 3.Upgrade-Insecure-Requests (升级为HTTPS请求)\n\n> **Upgrade-Insecure-Requests**：升级不安全的请求，意思是会在加载 http 资源时自动替换成 https 请求，让浏览器不再显示https页面中的http请求警报。\n\n##### 4.User-Agent(浏览器名称)\n\n> **User-Agent**：是客户浏览器的名称。\n\n##### 5.Accept（传输文件类型）\n\n> **Accept**：指浏览器或其他客户端可以接受的MIME（Multipurpose Internet Mail Extensions（多用途互联网邮件扩展））文件类型，服务器可以根据它判断并返回适当的文件格式。\n\n- `Accept: \\*/\\*`：表示什么都可以接收。\n- `Accept: image/gif`：表示客户端希望接收GIF图像格式的资源。\n- `Accept: text/html`：表示客户端希望接收html文本。\n- `Accept: text/html, application/xhtml+xml;q=0.9, image/*;q=0.8`：表示浏览器支持的MIME类型分别是html文本、xhtml和xml文档、所有的图像格式资源。\n\n> `q`是权重系数，范围0 =< q <= 1，`q`值越大，请求越倾向于获得其“`;`”之前的类型表示的内容。若没有指定`q`值，则默认为1，按照从左到右排序顺序；若被赋值为0，则用于表示浏览器不接收此内容类型。\n>\n> `Text`：用于标准化的表示的文本信息，文本消息可以是多种字符集和或者多种格式的。\n>\n> `Application`：用于传输应用程序数据或者二进制数据。\n\n##### 6.Referer（页面跳转处）\n\n> **Referer**：表明产生请求的网页来自于哪个URL，用户是从该 Referer页面访问到当前请求的页面。这个属性可以用来跟踪Web请求来自哪个页面，是从什么网站来的等。例如防盗链原理。\n\n##### 7.Accept-Encoding（文件编解码格式）\n\n> **Accept-Encoding**：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后先解码，然后再检查文件格式，许多情形下这可以减少大量的下载时间。\n\n- `Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0`：如果有多个Encoding同时匹配, 按照q值顺序排列，本例中按顺序支持 gzip, identity压缩编码，支持gzip的浏览器会返回经过gzip编码的HTML页面。 如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。\n\n##### 8.Accept-Language（语言种类）\n\n> **Accept-Langeuage**：指出浏览器可以接受的语言种类，如en或en-us指英语，zh或者zh-cn指中文，当服务器能够提供一种以上的语言版本时要用到。\n\n##### 9.Accept-Charset（字符编码）\n\n> **Accept-Charset**：指出浏览器可以接受的字符编码。\n\n- `Accept-Charset:iso-8859-1,gb2312,utf-8`：本例中支持`ISO8859-1`、`gb2312`、`utf-8`编码。如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。\n\n##### 10.Cookie\n\n> **Cookie**：浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。\n\n##### 11.Content-Type （POST数据类型）\n\n> **Content-Type**：POST请求里用来表示的内容类型。\n\n- `Content-Type = Text/XML; charset=gb2312`：指明该请求中的消息体中包含的是纯文本的`XML`类型的数据，字符编码采用`gb2312`。\n\n#### 5.服务端常用的响应报头\n\n> HTTP响应由四个部分组成，分别是： **状态行**、**消息报头**、**空行**、**响应正文**。\n\n##### 1.Cache-Control: must-revalidate, no-cache, private\n\n> 这个值告诉客户端，服务端不希望客户端缓存资源，在下次请求资源时，必须要重新请求服务器，不能从缓存中获取资源。\n\n- `Cache-Control`是响应头中很重要的信息，当客户端请求头中包含`Cache-Control: max-age = 0`请求，明确表示不会缓存服务器资源时，`Cache-Control`作为回应信息，通常会返回`no-cache`。\n- 当客户端在请求头中没有包含`Cache-Control`时，服务端往往会定不同的资源不同的缓存策略，比如说oschina在缓存图片资源的策略是`Cache-Control: max-age = 86400`，这个意思是，从当前时间开始，在86400秒的时间内，客户端可以直接从缓存中读取资源，而不需要向服务器请求。\n\n##### 2.Connection: keep-alive\n\n> 这个字段作为回应客户端的`Connection: keep-alive`，告诉客户端服务器的TCP连接也是一个长连接，客户端可以继续使用这个TCP连接发送HTTP请求。\n\n##### 3.Content-Encoding: gzip\n\n> 告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码。\n\n##### 4.Content-Type: text/html; charset = UTF-8\n\n> 告诉客户端，资源文件的类型和字符编码，客户端通过UTF-8对资源进行解码，然后对资源进行html解析。\n\n##### 5.Date: Sun, 21 Sep 2016 06:18:21 GMT\n\n> 服务端发送资源时的服务器时间。\n\n##### 6.Expires: Sun, 1 Jan 2000 01:00:00 GMT\n\n> 告诉客户端可以在这个时间前直接访问缓存。该值存在问题，客户端和服务器的时间不一定都是相同的，所有没有`Cache-Control: max-age = *` 准确。\n\n##### 7.Pragma: no-cache\n\n> 含义与`Cache-Control`相同\n\n##### 8.Server: Tengine/1.4.6\n\n> 服务器和相对应的版本，告诉客户端服务器的信息。\n\n##### 9.Transfer-Encoding: chunked\n\n> 告诉客户端，服务器发送的资源方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。\n\n##### 10.Vary: Accept-Encoding\n\n> 告诉缓存服务器，缓存压缩文件和非压缩文件两个版本。\n\n#### 6.响应状态码\n\n- `100～199`：表示服务器成功接收部分请求，要求客户端继续提交其余请求才能完成整个处理过程。\n- `200～299`：表示服务器成功接收请求并 已完成整个处理过程。常用`200`（OK请求成功）。\n- `300～399`：为完成请求，客户端需进一步细化请求。例如：请求的资源已经移动一个新地址，常用`302`（所请求的页面已经临时转移至新的URL）、`307`和`304`（使用缓存资源）。\n- `400～499`：客户端的请求有错误，常用`404`（服务器无法找到被请求的页面）、`403`（服务器拒绝访问，权限不够）。\n- `500～599`：服务端出现错误，常用`500`（请求未完成。服务器遇到不可预知的情况）。\n\n#### 7.Cookie和Session\n\n> 服务器和客户端的交互仅限于请求/响应过程，结束之后便断开，在下一次请求时，服务器会认为新的客户端。为了维护他们之间的连接，让服务器知道这是前一个用户发送的请求，必须在一个地方保存客户端的信息。\n\n- `Cooke`：通过在客户端记录的信息确定用户的身份。\n- `Session`：通过在服务端记录的信息确定用户的身份。\n\n## HTTPS\n\n> HTTPS = HTTP + SSL/TLS\n>\n> SSL：Secure Sockets Layer 安全套接层\n>\n> TLS：ransport Layer Security 安全传输层协议。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）\n\n##### 1.客户端发起HTTPS请求\n\n##### 2.服务端的配置\n\n> 采用HTTPS协议的服务器必须有一套数字证书，包含一对公钥和私钥。\n\n##### 3.传送证书\n\n> 该证书是公钥，包含证书的颁发机构、过期时间等等。\n\n##### 4.客户端解析证书\n\n> 由客户端的TLS完成，首先验证公钥是否有效，比如颁发机构、过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密。\n\n##### 5.传送加密信息\n\n> 传送的是用证书加密后的随机值，目的是让服务端得到这个随机值，以后客户端和服务端通信就可以通过这个随机值来进行加密解密了。\n\n##### 6.服务端解密信息\n\n> 服务端用私钥解密后，得到了客户端传过来的随机值（私钥），然后把内容通过该值进行对称加密。\n\n##### 7.传输加密后的信息\n\n##### 8.客户端解密信息\n\n> 客户端用之前生成的私钥解密服务端传过来的信息，于是获取了解密后的内容。\n\n![RSA密钥交换过程](./images/HTTP和HTTPS.JPG)\n\n## 不同点\n\n- HTTP协议是运行在TCP之上，所有传输的内容都是明文，客户端和服务端都无法验证对方的身份。\n- HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS是运行在TCP之上。所有传输的内容都是经过加密，加密采用对称加密，但对称加密的密钥用服务器的证书进行了非对称加密。\n\n## TCP建立连接的三次握手\n\n> **FLAGS字段：**\n>\n> SYN：表示建立连接。\n>\n> FIN：表示关闭连接。\n>\n> ACK：表示响应。\n>\n> PSH：表示有DATA数据传输。\n>\n> RST：表示连接重置。\n\n- 第一次握手：主机A发送位码为syn＝1，随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机。\n- 第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包。\n- 第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。\n\n完成三次握手，主机A与主机B开始传送数据。\n\n## TCP断开连接的四次握手\n\n> TCP断开连接有两种方式，第一种是正常的四次握手断开的，第二种是RST异常断开的\n\n##### 1.正常断开\n\n- 服务器80端口向41826端口发出FIN的断开连接请求。\n- 41826端口收到请求之后向服务器80端口回复了一个ACK。\n- 41826端口向服务器80端口发送断开请求FIN。\n- 服务器80向客户端发送断开的回复ACK。\n\n##### 2.异常断开\n\n- 服务器80端口向41826端口发出FIN的断开连接请求。\n- 41826端口收到请求之后向服务器80端口回复了一个ACK。\n- 41826端口向服务器80端口发送了GET请求。\n- 41826端口向服务器80端口发送断开请求FIN。\n- 服务器端口80因为原因没有确认客户端发送的确认请求而断开，因此返回了RST。","slug":"HTTP-and-HTTPS","published":1,"updated":"2018-04-19T09:28:07.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg6c1dy40003gzxffik8jghn","content":"<p><img src=\"/assets/blogImg/http-https-top.jpg\" alt=\"top\"></p>\n<a id=\"more\"></a>\n<blockquote>\n<p><strong>HTTP协议（HyperText Transfer Protocol，超文本传输协议）</strong>：是一种用于分布式、协作式和超媒体信息系统的应用层协议。目的是为了提供一种发布和接收HTML页面的方法。默认端口号为<code>80</code>。</p>\n<p><strong>HTTPS协议（Hypertext Transfer Protocol Secure）</strong>：是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。默认端口号为<code>443</code>。</p>\n<blockquote>\n<p>引自维基百科<a href=\"https://zh.wikipedia.org/wiki/超文本传输协议\" target=\"_blank\" rel=\"noopener\">HTTP</a>和<a href=\"https://zh.wikipedia.org/wiki/超文本传输安全协议\" target=\"_blank\" rel=\"noopener\">HTTPS</a></p>\n</blockquote>\n</blockquote>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><h4 id=\"1-协议概述\"><a href=\"#1-协议概述\" class=\"headerlink\" title=\"1. 协议概述\"></a>1. 协议概述</h4><p>​    由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p>\n<h4 id=\"2-URL\"><a href=\"#2-URL\" class=\"headerlink\" title=\"2. URL\"></a>2. URL</h4><blockquote>\n<p><strong>URL（Uniform / Universal Resource Locator）</strong>：统一资源定位符，是用于完整地描述Internet上网页和其他资源的地址的一种标识方法。</p>\n</blockquote>\n<p><strong>基本格式</strong>：<code>scheme://host[:port#]/path/…/[?query-string][#anchor]</code></p>\n<ul>\n<li><strong>scheme</strong>：协议(例如：http, https, ftp)</li>\n<li><strong>host</strong>：服务器的IP地址或者域名</li>\n<li><strong>port</strong>#：服务器的端口（如果是走协议默认端口，缺省端口80）</li>\n<li><strong>path</strong>：访问资源的路径</li>\n<li><strong>query-string</strong>：参数，发送给http服务器的数据</li>\n<li><strong>anchor</strong>：锚（跳转到网页的指定锚点位置）</li>\n</ul>\n<h4 id=\"3-请求方法（HTTP-1-1）\"><a href=\"#3-请求方法（HTTP-1-1）\" class=\"headerlink\" title=\"3. 请求方法（HTTP/1.1）\"></a>3. 请求方法（HTTP/1.1）</h4><ol>\n<li><strong>GET</strong>：请求指定的页面信息，并返回实体主体。参数显示在URL中。</li>\n<li><strong>HEAD</strong>：类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头。</li>\n<li><strong>POST</strong>：向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。参数在请求体中。</li>\n<li><strong>PUT</strong>：从客户端向服务器传达的数据取代指定的文档的内容。</li>\n<li><strong>DELETE</strong>：请求服务器删除指定的页面。</li>\n<li><strong>CONNECT</strong>：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li>\n<li><strong>OPTIONS</strong>：允许客户端查看服务器的性能。</li>\n<li><strong>TRACE</strong>：回显服务器收到的请求，主要用于测试或诊断。</li>\n</ol>\n<blockquote>\n<p>避免使用<code>GET</code>方式提交表单，因为有可能会导致安全问题。比如说在登陆表单中用Get方式，用户输入的用户名和密码将在地址栏中暴露无遗。</p>\n</blockquote>\n<h4 id=\"4-常用的请求报头\"><a href=\"#4-常用的请求报头\" class=\"headerlink\" title=\"4.常用的请求报头\"></a>4.常用的请求报头</h4><blockquote>\n<p>HTTP请求由四个部分组成，分别是：<strong>请求行</strong>、<strong>请求头部</strong>、<strong>空行</strong>、<strong>请求数据</strong>。</p>\n</blockquote>\n<h5 id=\"1-Host（主机和端口号）\"><a href=\"#1-Host（主机和端口号）\" class=\"headerlink\" title=\"1.Host（主机和端口号）\"></a>1.Host（主机和端口号）</h5><blockquote>\n<p><strong>Host</strong>：对应网址URL中的Web名称和端口号，用于指定被请求资源的Internet主机和端口号，通常属于URL的一部分。</p>\n</blockquote>\n<h5 id=\"2-Connection-链接类型\"><a href=\"#2-Connection-链接类型\" class=\"headerlink\" title=\"2.Connection (链接类型)\"></a>2.Connection (链接类型)</h5><blockquote>\n<p><strong>Connection</strong>：表示客户端与服务连接类型.</p>\n</blockquote>\n<ol>\n<li>Client 发起一个包含 <code>Connection:keep-alive</code> 的请求，HTTP/1.1使用 <code>keep-alive</code> 为默认值。</li>\n<li>Server收到请求后：<ul>\n<li>如果 Server 支持 <code>keep-alive</code>，回复一个包含 <code>Connection:keep-alive</code> 的响应，不关闭连接；</li>\n<li>如果 Server 不支持 <code>keep-alive</code>，回复一个包含 <code>Connection:close</code> 的响应，关闭连接。</li>\n</ul>\n</li>\n<li>如果client收到包含 <code>Connection:keep-alive</code> 的响应，向同一个连接发送下一个请求，直到一方主动关闭连接。</li>\n</ol>\n<blockquote>\n<p><code>keep-alive</code>在很多情况下能够重用连接，减少资源消耗，缩短响应时间，比如当浏览器需要多个文件时(比如一个HTML文件和相关的图形文件)，不需要每次都去请求建立连接。</p>\n</blockquote>\n<h5 id=\"3-Upgrade-Insecure-Requests-升级为HTTPS请求\"><a href=\"#3-Upgrade-Insecure-Requests-升级为HTTPS请求\" class=\"headerlink\" title=\"3.Upgrade-Insecure-Requests (升级为HTTPS请求)\"></a>3.Upgrade-Insecure-Requests (升级为HTTPS请求)</h5><blockquote>\n<p><strong>Upgrade-Insecure-Requests</strong>：升级不安全的请求，意思是会在加载 http 资源时自动替换成 https 请求，让浏览器不再显示https页面中的http请求警报。</p>\n</blockquote>\n<h5 id=\"4-User-Agent-浏览器名称\"><a href=\"#4-User-Agent-浏览器名称\" class=\"headerlink\" title=\"4.User-Agent(浏览器名称)\"></a>4.User-Agent(浏览器名称)</h5><blockquote>\n<p><strong>User-Agent</strong>：是客户浏览器的名称。</p>\n</blockquote>\n<h5 id=\"5-Accept（传输文件类型）\"><a href=\"#5-Accept（传输文件类型）\" class=\"headerlink\" title=\"5.Accept（传输文件类型）\"></a>5.Accept（传输文件类型）</h5><blockquote>\n<p><strong>Accept</strong>：指浏览器或其他客户端可以接受的MIME（Multipurpose Internet Mail Extensions（多用途互联网邮件扩展））文件类型，服务器可以根据它判断并返回适当的文件格式。</p>\n</blockquote>\n<ul>\n<li><code>Accept: \\*/\\*</code>：表示什么都可以接收。</li>\n<li><code>Accept: image/gif</code>：表示客户端希望接收GIF图像格式的资源。</li>\n<li><code>Accept: text/html</code>：表示客户端希望接收html文本。</li>\n<li><code>Accept: text/html, application/xhtml+xml;q=0.9, image/*;q=0.8</code>：表示浏览器支持的MIME类型分别是html文本、xhtml和xml文档、所有的图像格式资源。</li>\n</ul>\n<blockquote>\n<p><code>q</code>是权重系数，范围0 =&lt; q &lt;= 1，<code>q</code>值越大，请求越倾向于获得其“<code>;</code>”之前的类型表示的内容。若没有指定<code>q</code>值，则默认为1，按照从左到右排序顺序；若被赋值为0，则用于表示浏览器不接收此内容类型。</p>\n<p><code>Text</code>：用于标准化的表示的文本信息，文本消息可以是多种字符集和或者多种格式的。</p>\n<p><code>Application</code>：用于传输应用程序数据或者二进制数据。</p>\n</blockquote>\n<h5 id=\"6-Referer（页面跳转处）\"><a href=\"#6-Referer（页面跳转处）\" class=\"headerlink\" title=\"6.Referer（页面跳转处）\"></a>6.Referer（页面跳转处）</h5><blockquote>\n<p><strong>Referer</strong>：表明产生请求的网页来自于哪个URL，用户是从该 Referer页面访问到当前请求的页面。这个属性可以用来跟踪Web请求来自哪个页面，是从什么网站来的等。例如防盗链原理。</p>\n</blockquote>\n<h5 id=\"7-Accept-Encoding（文件编解码格式）\"><a href=\"#7-Accept-Encoding（文件编解码格式）\" class=\"headerlink\" title=\"7.Accept-Encoding（文件编解码格式）\"></a>7.Accept-Encoding（文件编解码格式）</h5><blockquote>\n<p><strong>Accept-Encoding</strong>：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后先解码，然后再检查文件格式，许多情形下这可以减少大量的下载时间。</p>\n</blockquote>\n<ul>\n<li><code>Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0</code>：如果有多个Encoding同时匹配, 按照q值顺序排列，本例中按顺序支持 gzip, identity压缩编码，支持gzip的浏览器会返回经过gzip编码的HTML页面。 如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。</li>\n</ul>\n<h5 id=\"8-Accept-Language（语言种类）\"><a href=\"#8-Accept-Language（语言种类）\" class=\"headerlink\" title=\"8.Accept-Language（语言种类）\"></a>8.Accept-Language（语言种类）</h5><blockquote>\n<p><strong>Accept-Langeuage</strong>：指出浏览器可以接受的语言种类，如en或en-us指英语，zh或者zh-cn指中文，当服务器能够提供一种以上的语言版本时要用到。</p>\n</blockquote>\n<h5 id=\"9-Accept-Charset（字符编码）\"><a href=\"#9-Accept-Charset（字符编码）\" class=\"headerlink\" title=\"9.Accept-Charset（字符编码）\"></a>9.Accept-Charset（字符编码）</h5><blockquote>\n<p><strong>Accept-Charset</strong>：指出浏览器可以接受的字符编码。</p>\n</blockquote>\n<ul>\n<li><code>Accept-Charset:iso-8859-1,gb2312,utf-8</code>：本例中支持<code>ISO8859-1</code>、<code>gb2312</code>、<code>utf-8</code>编码。如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。</li>\n</ul>\n<h5 id=\"10-Cookie\"><a href=\"#10-Cookie\" class=\"headerlink\" title=\"10.Cookie\"></a>10.Cookie</h5><blockquote>\n<p><strong>Cookie</strong>：浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。</p>\n</blockquote>\n<h5 id=\"11-Content-Type-（POST数据类型）\"><a href=\"#11-Content-Type-（POST数据类型）\" class=\"headerlink\" title=\"11.Content-Type （POST数据类型）\"></a>11.Content-Type （POST数据类型）</h5><blockquote>\n<p><strong>Content-Type</strong>：POST请求里用来表示的内容类型。</p>\n</blockquote>\n<ul>\n<li><code>Content-Type = Text/XML; charset=gb2312</code>：指明该请求中的消息体中包含的是纯文本的<code>XML</code>类型的数据，字符编码采用<code>gb2312</code>。</li>\n</ul>\n<h4 id=\"5-服务端常用的响应报头\"><a href=\"#5-服务端常用的响应报头\" class=\"headerlink\" title=\"5.服务端常用的响应报头\"></a>5.服务端常用的响应报头</h4><blockquote>\n<p>HTTP响应由四个部分组成，分别是： <strong>状态行</strong>、<strong>消息报头</strong>、<strong>空行</strong>、<strong>响应正文</strong>。</p>\n</blockquote>\n<h5 id=\"1-Cache-Control-must-revalidate-no-cache-private\"><a href=\"#1-Cache-Control-must-revalidate-no-cache-private\" class=\"headerlink\" title=\"1.Cache-Control: must-revalidate, no-cache, private\"></a>1.Cache-Control: must-revalidate, no-cache, private</h5><blockquote>\n<p>这个值告诉客户端，服务端不希望客户端缓存资源，在下次请求资源时，必须要重新请求服务器，不能从缓存中获取资源。</p>\n</blockquote>\n<ul>\n<li><code>Cache-Control</code>是响应头中很重要的信息，当客户端请求头中包含<code>Cache-Control: max-age = 0</code>请求，明确表示不会缓存服务器资源时，<code>Cache-Control</code>作为回应信息，通常会返回<code>no-cache</code>。</li>\n<li>当客户端在请求头中没有包含<code>Cache-Control</code>时，服务端往往会定不同的资源不同的缓存策略，比如说oschina在缓存图片资源的策略是<code>Cache-Control: max-age = 86400</code>，这个意思是，从当前时间开始，在86400秒的时间内，客户端可以直接从缓存中读取资源，而不需要向服务器请求。</li>\n</ul>\n<h5 id=\"2-Connection-keep-alive\"><a href=\"#2-Connection-keep-alive\" class=\"headerlink\" title=\"2.Connection: keep-alive\"></a>2.Connection: keep-alive</h5><blockquote>\n<p>这个字段作为回应客户端的<code>Connection: keep-alive</code>，告诉客户端服务器的TCP连接也是一个长连接，客户端可以继续使用这个TCP连接发送HTTP请求。</p>\n</blockquote>\n<h5 id=\"3-Content-Encoding-gzip\"><a href=\"#3-Content-Encoding-gzip\" class=\"headerlink\" title=\"3.Content-Encoding: gzip\"></a>3.Content-Encoding: gzip</h5><blockquote>\n<p>告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码。</p>\n</blockquote>\n<h5 id=\"4-Content-Type-text-html-charset-UTF-8\"><a href=\"#4-Content-Type-text-html-charset-UTF-8\" class=\"headerlink\" title=\"4.Content-Type: text/html; charset = UTF-8\"></a>4.Content-Type: text/html; charset = UTF-8</h5><blockquote>\n<p>告诉客户端，资源文件的类型和字符编码，客户端通过UTF-8对资源进行解码，然后对资源进行html解析。</p>\n</blockquote>\n<h5 id=\"5-Date-Sun-21-Sep-2016-06-18-21-GMT\"><a href=\"#5-Date-Sun-21-Sep-2016-06-18-21-GMT\" class=\"headerlink\" title=\"5.Date: Sun, 21 Sep 2016 06:18:21 GMT\"></a>5.Date: Sun, 21 Sep 2016 06:18:21 GMT</h5><blockquote>\n<p>服务端发送资源时的服务器时间。</p>\n</blockquote>\n<h5 id=\"6-Expires-Sun-1-Jan-2000-01-00-00-GMT\"><a href=\"#6-Expires-Sun-1-Jan-2000-01-00-00-GMT\" class=\"headerlink\" title=\"6.Expires: Sun, 1 Jan 2000 01:00:00 GMT\"></a>6.Expires: Sun, 1 Jan 2000 01:00:00 GMT</h5><blockquote>\n<p>告诉客户端可以在这个时间前直接访问缓存。该值存在问题，客户端和服务器的时间不一定都是相同的，所有没有<code>Cache-Control: max-age = *</code> 准确。</p>\n</blockquote>\n<h5 id=\"7-Pragma-no-cache\"><a href=\"#7-Pragma-no-cache\" class=\"headerlink\" title=\"7.Pragma: no-cache\"></a>7.Pragma: no-cache</h5><blockquote>\n<p>含义与<code>Cache-Control</code>相同</p>\n</blockquote>\n<h5 id=\"8-Server-Tengine-1-4-6\"><a href=\"#8-Server-Tengine-1-4-6\" class=\"headerlink\" title=\"8.Server: Tengine/1.4.6\"></a>8.Server: Tengine/1.4.6</h5><blockquote>\n<p>服务器和相对应的版本，告诉客户端服务器的信息。</p>\n</blockquote>\n<h5 id=\"9-Transfer-Encoding-chunked\"><a href=\"#9-Transfer-Encoding-chunked\" class=\"headerlink\" title=\"9.Transfer-Encoding: chunked\"></a>9.Transfer-Encoding: chunked</h5><blockquote>\n<p>告诉客户端，服务器发送的资源方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。</p>\n</blockquote>\n<h5 id=\"10-Vary-Accept-Encoding\"><a href=\"#10-Vary-Accept-Encoding\" class=\"headerlink\" title=\"10.Vary: Accept-Encoding\"></a>10.Vary: Accept-Encoding</h5><blockquote>\n<p>告诉缓存服务器，缓存压缩文件和非压缩文件两个版本。</p>\n</blockquote>\n<h4 id=\"6-响应状态码\"><a href=\"#6-响应状态码\" class=\"headerlink\" title=\"6.响应状态码\"></a>6.响应状态码</h4><ul>\n<li><code>100～199</code>：表示服务器成功接收部分请求，要求客户端继续提交其余请求才能完成整个处理过程。</li>\n<li><code>200～299</code>：表示服务器成功接收请求并 已完成整个处理过程。常用<code>200</code>（OK请求成功）。</li>\n<li><code>300～399</code>：为完成请求，客户端需进一步细化请求。例如：请求的资源已经移动一个新地址，常用<code>302</code>（所请求的页面已经临时转移至新的URL）、<code>307</code>和<code>304</code>（使用缓存资源）。</li>\n<li><code>400～499</code>：客户端的请求有错误，常用<code>404</code>（服务器无法找到被请求的页面）、<code>403</code>（服务器拒绝访问，权限不够）。</li>\n<li><code>500～599</code>：服务端出现错误，常用<code>500</code>（请求未完成。服务器遇到不可预知的情况）。</li>\n</ul>\n<h4 id=\"7-Cookie和Session\"><a href=\"#7-Cookie和Session\" class=\"headerlink\" title=\"7.Cookie和Session\"></a>7.Cookie和Session</h4><blockquote>\n<p>服务器和客户端的交互仅限于请求/响应过程，结束之后便断开，在下一次请求时，服务器会认为新的客户端。为了维护他们之间的连接，让服务器知道这是前一个用户发送的请求，必须在一个地方保存客户端的信息。</p>\n</blockquote>\n<ul>\n<li><code>Cooke</code>：通过在客户端记录的信息确定用户的身份。</li>\n<li><code>Session</code>：通过在服务端记录的信息确定用户的身份。</li>\n</ul>\n<h2 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h2><blockquote>\n<p>HTTPS = HTTP + SSL/TLS</p>\n<p>SSL：Secure Sockets Layer 安全套接层</p>\n<p>TLS：ransport Layer Security 安全传输层协议。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）</p>\n</blockquote>\n<h5 id=\"1-客户端发起HTTPS请求\"><a href=\"#1-客户端发起HTTPS请求\" class=\"headerlink\" title=\"1.客户端发起HTTPS请求\"></a>1.客户端发起HTTPS请求</h5><h5 id=\"2-服务端的配置\"><a href=\"#2-服务端的配置\" class=\"headerlink\" title=\"2.服务端的配置\"></a>2.服务端的配置</h5><blockquote>\n<p>采用HTTPS协议的服务器必须有一套数字证书，包含一对公钥和私钥。</p>\n</blockquote>\n<h5 id=\"3-传送证书\"><a href=\"#3-传送证书\" class=\"headerlink\" title=\"3.传送证书\"></a>3.传送证书</h5><blockquote>\n<p>该证书是公钥，包含证书的颁发机构、过期时间等等。</p>\n</blockquote>\n<h5 id=\"4-客户端解析证书\"><a href=\"#4-客户端解析证书\" class=\"headerlink\" title=\"4.客户端解析证书\"></a>4.客户端解析证书</h5><blockquote>\n<p>由客户端的TLS完成，首先验证公钥是否有效，比如颁发机构、过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密。</p>\n</blockquote>\n<h5 id=\"5-传送加密信息\"><a href=\"#5-传送加密信息\" class=\"headerlink\" title=\"5.传送加密信息\"></a>5.传送加密信息</h5><blockquote>\n<p>传送的是用证书加密后的随机值，目的是让服务端得到这个随机值，以后客户端和服务端通信就可以通过这个随机值来进行加密解密了。</p>\n</blockquote>\n<h5 id=\"6-服务端解密信息\"><a href=\"#6-服务端解密信息\" class=\"headerlink\" title=\"6.服务端解密信息\"></a>6.服务端解密信息</h5><blockquote>\n<p>服务端用私钥解密后，得到了客户端传过来的随机值（私钥），然后把内容通过该值进行对称加密。</p>\n</blockquote>\n<h5 id=\"7-传输加密后的信息\"><a href=\"#7-传输加密后的信息\" class=\"headerlink\" title=\"7.传输加密后的信息\"></a>7.传输加密后的信息</h5><h5 id=\"8-客户端解密信息\"><a href=\"#8-客户端解密信息\" class=\"headerlink\" title=\"8.客户端解密信息\"></a>8.客户端解密信息</h5><blockquote>\n<p>客户端用之前生成的私钥解密服务端传过来的信息，于是获取了解密后的内容。</p>\n</blockquote>\n<p><img src=\"./images/HTTP和HTTPS.JPG\" alt=\"RSA密钥交换过程\"></p>\n<h2 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h2><ul>\n<li>HTTP协议是运行在TCP之上，所有传输的内容都是明文，客户端和服务端都无法验证对方的身份。</li>\n<li>HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS是运行在TCP之上。所有传输的内容都是经过加密，加密采用对称加密，但对称加密的密钥用服务器的证书进行了非对称加密。</li>\n</ul>\n<h2 id=\"TCP建立连接的三次握手\"><a href=\"#TCP建立连接的三次握手\" class=\"headerlink\" title=\"TCP建立连接的三次握手\"></a>TCP建立连接的三次握手</h2><blockquote>\n<p><strong>FLAGS字段：</strong></p>\n<p>SYN：表示建立连接。</p>\n<p>FIN：表示关闭连接。</p>\n<p>ACK：表示响应。</p>\n<p>PSH：表示有DATA数据传输。</p>\n<p>RST：表示连接重置。</p>\n</blockquote>\n<ul>\n<li>第一次握手：主机A发送位码为syn＝1，随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机。</li>\n<li>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包。</li>\n<li>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。</li>\n</ul>\n<p>完成三次握手，主机A与主机B开始传送数据。</p>\n<h2 id=\"TCP断开连接的四次握手\"><a href=\"#TCP断开连接的四次握手\" class=\"headerlink\" title=\"TCP断开连接的四次握手\"></a>TCP断开连接的四次握手</h2><blockquote>\n<p>TCP断开连接有两种方式，第一种是正常的四次握手断开的，第二种是RST异常断开的</p>\n</blockquote>\n<h5 id=\"1-正常断开\"><a href=\"#1-正常断开\" class=\"headerlink\" title=\"1.正常断开\"></a>1.正常断开</h5><ul>\n<li>服务器80端口向41826端口发出FIN的断开连接请求。</li>\n<li>41826端口收到请求之后向服务器80端口回复了一个ACK。</li>\n<li>41826端口向服务器80端口发送断开请求FIN。</li>\n<li>服务器80向客户端发送断开的回复ACK。</li>\n</ul>\n<h5 id=\"2-异常断开\"><a href=\"#2-异常断开\" class=\"headerlink\" title=\"2.异常断开\"></a>2.异常断开</h5><ul>\n<li>服务器80端口向41826端口发出FIN的断开连接请求。</li>\n<li>41826端口收到请求之后向服务器80端口回复了一个ACK。</li>\n<li>41826端口向服务器80端口发送了GET请求。</li>\n<li>41826端口向服务器80端口发送断开请求FIN。</li>\n<li>服务器端口80因为原因没有确认客户端发送的确认请求而断开，因此返回了RST。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><img src=\"/assets/blogImg/http-https-top.jpg\" alt=\"top\"></p>","more":"<blockquote>\n<p><strong>HTTP协议（HyperText Transfer Protocol，超文本传输协议）</strong>：是一种用于分布式、协作式和超媒体信息系统的应用层协议。目的是为了提供一种发布和接收HTML页面的方法。默认端口号为<code>80</code>。</p>\n<p><strong>HTTPS协议（Hypertext Transfer Protocol Secure）</strong>：是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。默认端口号为<code>443</code>。</p>\n<blockquote>\n<p>引自维基百科<a href=\"https://zh.wikipedia.org/wiki/超文本传输协议\" target=\"_blank\" rel=\"noopener\">HTTP</a>和<a href=\"https://zh.wikipedia.org/wiki/超文本传输安全协议\" target=\"_blank\" rel=\"noopener\">HTTPS</a></p>\n</blockquote>\n</blockquote>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><h4 id=\"1-协议概述\"><a href=\"#1-协议概述\" class=\"headerlink\" title=\"1. 协议概述\"></a>1. 协议概述</h4><p>​    由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p>\n<h4 id=\"2-URL\"><a href=\"#2-URL\" class=\"headerlink\" title=\"2. URL\"></a>2. URL</h4><blockquote>\n<p><strong>URL（Uniform / Universal Resource Locator）</strong>：统一资源定位符，是用于完整地描述Internet上网页和其他资源的地址的一种标识方法。</p>\n</blockquote>\n<p><strong>基本格式</strong>：<code>scheme://host[:port#]/path/…/[?query-string][#anchor]</code></p>\n<ul>\n<li><strong>scheme</strong>：协议(例如：http, https, ftp)</li>\n<li><strong>host</strong>：服务器的IP地址或者域名</li>\n<li><strong>port</strong>#：服务器的端口（如果是走协议默认端口，缺省端口80）</li>\n<li><strong>path</strong>：访问资源的路径</li>\n<li><strong>query-string</strong>：参数，发送给http服务器的数据</li>\n<li><strong>anchor</strong>：锚（跳转到网页的指定锚点位置）</li>\n</ul>\n<h4 id=\"3-请求方法（HTTP-1-1）\"><a href=\"#3-请求方法（HTTP-1-1）\" class=\"headerlink\" title=\"3. 请求方法（HTTP/1.1）\"></a>3. 请求方法（HTTP/1.1）</h4><ol>\n<li><strong>GET</strong>：请求指定的页面信息，并返回实体主体。参数显示在URL中。</li>\n<li><strong>HEAD</strong>：类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头。</li>\n<li><strong>POST</strong>：向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。参数在请求体中。</li>\n<li><strong>PUT</strong>：从客户端向服务器传达的数据取代指定的文档的内容。</li>\n<li><strong>DELETE</strong>：请求服务器删除指定的页面。</li>\n<li><strong>CONNECT</strong>：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li>\n<li><strong>OPTIONS</strong>：允许客户端查看服务器的性能。</li>\n<li><strong>TRACE</strong>：回显服务器收到的请求，主要用于测试或诊断。</li>\n</ol>\n<blockquote>\n<p>避免使用<code>GET</code>方式提交表单，因为有可能会导致安全问题。比如说在登陆表单中用Get方式，用户输入的用户名和密码将在地址栏中暴露无遗。</p>\n</blockquote>\n<h4 id=\"4-常用的请求报头\"><a href=\"#4-常用的请求报头\" class=\"headerlink\" title=\"4.常用的请求报头\"></a>4.常用的请求报头</h4><blockquote>\n<p>HTTP请求由四个部分组成，分别是：<strong>请求行</strong>、<strong>请求头部</strong>、<strong>空行</strong>、<strong>请求数据</strong>。</p>\n</blockquote>\n<h5 id=\"1-Host（主机和端口号）\"><a href=\"#1-Host（主机和端口号）\" class=\"headerlink\" title=\"1.Host（主机和端口号）\"></a>1.Host（主机和端口号）</h5><blockquote>\n<p><strong>Host</strong>：对应网址URL中的Web名称和端口号，用于指定被请求资源的Internet主机和端口号，通常属于URL的一部分。</p>\n</blockquote>\n<h5 id=\"2-Connection-链接类型\"><a href=\"#2-Connection-链接类型\" class=\"headerlink\" title=\"2.Connection (链接类型)\"></a>2.Connection (链接类型)</h5><blockquote>\n<p><strong>Connection</strong>：表示客户端与服务连接类型.</p>\n</blockquote>\n<ol>\n<li>Client 发起一个包含 <code>Connection:keep-alive</code> 的请求，HTTP/1.1使用 <code>keep-alive</code> 为默认值。</li>\n<li>Server收到请求后：<ul>\n<li>如果 Server 支持 <code>keep-alive</code>，回复一个包含 <code>Connection:keep-alive</code> 的响应，不关闭连接；</li>\n<li>如果 Server 不支持 <code>keep-alive</code>，回复一个包含 <code>Connection:close</code> 的响应，关闭连接。</li>\n</ul>\n</li>\n<li>如果client收到包含 <code>Connection:keep-alive</code> 的响应，向同一个连接发送下一个请求，直到一方主动关闭连接。</li>\n</ol>\n<blockquote>\n<p><code>keep-alive</code>在很多情况下能够重用连接，减少资源消耗，缩短响应时间，比如当浏览器需要多个文件时(比如一个HTML文件和相关的图形文件)，不需要每次都去请求建立连接。</p>\n</blockquote>\n<h5 id=\"3-Upgrade-Insecure-Requests-升级为HTTPS请求\"><a href=\"#3-Upgrade-Insecure-Requests-升级为HTTPS请求\" class=\"headerlink\" title=\"3.Upgrade-Insecure-Requests (升级为HTTPS请求)\"></a>3.Upgrade-Insecure-Requests (升级为HTTPS请求)</h5><blockquote>\n<p><strong>Upgrade-Insecure-Requests</strong>：升级不安全的请求，意思是会在加载 http 资源时自动替换成 https 请求，让浏览器不再显示https页面中的http请求警报。</p>\n</blockquote>\n<h5 id=\"4-User-Agent-浏览器名称\"><a href=\"#4-User-Agent-浏览器名称\" class=\"headerlink\" title=\"4.User-Agent(浏览器名称)\"></a>4.User-Agent(浏览器名称)</h5><blockquote>\n<p><strong>User-Agent</strong>：是客户浏览器的名称。</p>\n</blockquote>\n<h5 id=\"5-Accept（传输文件类型）\"><a href=\"#5-Accept（传输文件类型）\" class=\"headerlink\" title=\"5.Accept（传输文件类型）\"></a>5.Accept（传输文件类型）</h5><blockquote>\n<p><strong>Accept</strong>：指浏览器或其他客户端可以接受的MIME（Multipurpose Internet Mail Extensions（多用途互联网邮件扩展））文件类型，服务器可以根据它判断并返回适当的文件格式。</p>\n</blockquote>\n<ul>\n<li><code>Accept: \\*/\\*</code>：表示什么都可以接收。</li>\n<li><code>Accept: image/gif</code>：表示客户端希望接收GIF图像格式的资源。</li>\n<li><code>Accept: text/html</code>：表示客户端希望接收html文本。</li>\n<li><code>Accept: text/html, application/xhtml+xml;q=0.9, image/*;q=0.8</code>：表示浏览器支持的MIME类型分别是html文本、xhtml和xml文档、所有的图像格式资源。</li>\n</ul>\n<blockquote>\n<p><code>q</code>是权重系数，范围0 =&lt; q &lt;= 1，<code>q</code>值越大，请求越倾向于获得其“<code>;</code>”之前的类型表示的内容。若没有指定<code>q</code>值，则默认为1，按照从左到右排序顺序；若被赋值为0，则用于表示浏览器不接收此内容类型。</p>\n<p><code>Text</code>：用于标准化的表示的文本信息，文本消息可以是多种字符集和或者多种格式的。</p>\n<p><code>Application</code>：用于传输应用程序数据或者二进制数据。</p>\n</blockquote>\n<h5 id=\"6-Referer（页面跳转处）\"><a href=\"#6-Referer（页面跳转处）\" class=\"headerlink\" title=\"6.Referer（页面跳转处）\"></a>6.Referer（页面跳转处）</h5><blockquote>\n<p><strong>Referer</strong>：表明产生请求的网页来自于哪个URL，用户是从该 Referer页面访问到当前请求的页面。这个属性可以用来跟踪Web请求来自哪个页面，是从什么网站来的等。例如防盗链原理。</p>\n</blockquote>\n<h5 id=\"7-Accept-Encoding（文件编解码格式）\"><a href=\"#7-Accept-Encoding（文件编解码格式）\" class=\"headerlink\" title=\"7.Accept-Encoding（文件编解码格式）\"></a>7.Accept-Encoding（文件编解码格式）</h5><blockquote>\n<p><strong>Accept-Encoding</strong>：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后先解码，然后再检查文件格式，许多情形下这可以减少大量的下载时间。</p>\n</blockquote>\n<ul>\n<li><code>Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0</code>：如果有多个Encoding同时匹配, 按照q值顺序排列，本例中按顺序支持 gzip, identity压缩编码，支持gzip的浏览器会返回经过gzip编码的HTML页面。 如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。</li>\n</ul>\n<h5 id=\"8-Accept-Language（语言种类）\"><a href=\"#8-Accept-Language（语言种类）\" class=\"headerlink\" title=\"8.Accept-Language（语言种类）\"></a>8.Accept-Language（语言种类）</h5><blockquote>\n<p><strong>Accept-Langeuage</strong>：指出浏览器可以接受的语言种类，如en或en-us指英语，zh或者zh-cn指中文，当服务器能够提供一种以上的语言版本时要用到。</p>\n</blockquote>\n<h5 id=\"9-Accept-Charset（字符编码）\"><a href=\"#9-Accept-Charset（字符编码）\" class=\"headerlink\" title=\"9.Accept-Charset（字符编码）\"></a>9.Accept-Charset（字符编码）</h5><blockquote>\n<p><strong>Accept-Charset</strong>：指出浏览器可以接受的字符编码。</p>\n</blockquote>\n<ul>\n<li><code>Accept-Charset:iso-8859-1,gb2312,utf-8</code>：本例中支持<code>ISO8859-1</code>、<code>gb2312</code>、<code>utf-8</code>编码。如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。</li>\n</ul>\n<h5 id=\"10-Cookie\"><a href=\"#10-Cookie\" class=\"headerlink\" title=\"10.Cookie\"></a>10.Cookie</h5><blockquote>\n<p><strong>Cookie</strong>：浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。</p>\n</blockquote>\n<h5 id=\"11-Content-Type-（POST数据类型）\"><a href=\"#11-Content-Type-（POST数据类型）\" class=\"headerlink\" title=\"11.Content-Type （POST数据类型）\"></a>11.Content-Type （POST数据类型）</h5><blockquote>\n<p><strong>Content-Type</strong>：POST请求里用来表示的内容类型。</p>\n</blockquote>\n<ul>\n<li><code>Content-Type = Text/XML; charset=gb2312</code>：指明该请求中的消息体中包含的是纯文本的<code>XML</code>类型的数据，字符编码采用<code>gb2312</code>。</li>\n</ul>\n<h4 id=\"5-服务端常用的响应报头\"><a href=\"#5-服务端常用的响应报头\" class=\"headerlink\" title=\"5.服务端常用的响应报头\"></a>5.服务端常用的响应报头</h4><blockquote>\n<p>HTTP响应由四个部分组成，分别是： <strong>状态行</strong>、<strong>消息报头</strong>、<strong>空行</strong>、<strong>响应正文</strong>。</p>\n</blockquote>\n<h5 id=\"1-Cache-Control-must-revalidate-no-cache-private\"><a href=\"#1-Cache-Control-must-revalidate-no-cache-private\" class=\"headerlink\" title=\"1.Cache-Control: must-revalidate, no-cache, private\"></a>1.Cache-Control: must-revalidate, no-cache, private</h5><blockquote>\n<p>这个值告诉客户端，服务端不希望客户端缓存资源，在下次请求资源时，必须要重新请求服务器，不能从缓存中获取资源。</p>\n</blockquote>\n<ul>\n<li><code>Cache-Control</code>是响应头中很重要的信息，当客户端请求头中包含<code>Cache-Control: max-age = 0</code>请求，明确表示不会缓存服务器资源时，<code>Cache-Control</code>作为回应信息，通常会返回<code>no-cache</code>。</li>\n<li>当客户端在请求头中没有包含<code>Cache-Control</code>时，服务端往往会定不同的资源不同的缓存策略，比如说oschina在缓存图片资源的策略是<code>Cache-Control: max-age = 86400</code>，这个意思是，从当前时间开始，在86400秒的时间内，客户端可以直接从缓存中读取资源，而不需要向服务器请求。</li>\n</ul>\n<h5 id=\"2-Connection-keep-alive\"><a href=\"#2-Connection-keep-alive\" class=\"headerlink\" title=\"2.Connection: keep-alive\"></a>2.Connection: keep-alive</h5><blockquote>\n<p>这个字段作为回应客户端的<code>Connection: keep-alive</code>，告诉客户端服务器的TCP连接也是一个长连接，客户端可以继续使用这个TCP连接发送HTTP请求。</p>\n</blockquote>\n<h5 id=\"3-Content-Encoding-gzip\"><a href=\"#3-Content-Encoding-gzip\" class=\"headerlink\" title=\"3.Content-Encoding: gzip\"></a>3.Content-Encoding: gzip</h5><blockquote>\n<p>告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码。</p>\n</blockquote>\n<h5 id=\"4-Content-Type-text-html-charset-UTF-8\"><a href=\"#4-Content-Type-text-html-charset-UTF-8\" class=\"headerlink\" title=\"4.Content-Type: text/html; charset = UTF-8\"></a>4.Content-Type: text/html; charset = UTF-8</h5><blockquote>\n<p>告诉客户端，资源文件的类型和字符编码，客户端通过UTF-8对资源进行解码，然后对资源进行html解析。</p>\n</blockquote>\n<h5 id=\"5-Date-Sun-21-Sep-2016-06-18-21-GMT\"><a href=\"#5-Date-Sun-21-Sep-2016-06-18-21-GMT\" class=\"headerlink\" title=\"5.Date: Sun, 21 Sep 2016 06:18:21 GMT\"></a>5.Date: Sun, 21 Sep 2016 06:18:21 GMT</h5><blockquote>\n<p>服务端发送资源时的服务器时间。</p>\n</blockquote>\n<h5 id=\"6-Expires-Sun-1-Jan-2000-01-00-00-GMT\"><a href=\"#6-Expires-Sun-1-Jan-2000-01-00-00-GMT\" class=\"headerlink\" title=\"6.Expires: Sun, 1 Jan 2000 01:00:00 GMT\"></a>6.Expires: Sun, 1 Jan 2000 01:00:00 GMT</h5><blockquote>\n<p>告诉客户端可以在这个时间前直接访问缓存。该值存在问题，客户端和服务器的时间不一定都是相同的，所有没有<code>Cache-Control: max-age = *</code> 准确。</p>\n</blockquote>\n<h5 id=\"7-Pragma-no-cache\"><a href=\"#7-Pragma-no-cache\" class=\"headerlink\" title=\"7.Pragma: no-cache\"></a>7.Pragma: no-cache</h5><blockquote>\n<p>含义与<code>Cache-Control</code>相同</p>\n</blockquote>\n<h5 id=\"8-Server-Tengine-1-4-6\"><a href=\"#8-Server-Tengine-1-4-6\" class=\"headerlink\" title=\"8.Server: Tengine/1.4.6\"></a>8.Server: Tengine/1.4.6</h5><blockquote>\n<p>服务器和相对应的版本，告诉客户端服务器的信息。</p>\n</blockquote>\n<h5 id=\"9-Transfer-Encoding-chunked\"><a href=\"#9-Transfer-Encoding-chunked\" class=\"headerlink\" title=\"9.Transfer-Encoding: chunked\"></a>9.Transfer-Encoding: chunked</h5><blockquote>\n<p>告诉客户端，服务器发送的资源方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。</p>\n</blockquote>\n<h5 id=\"10-Vary-Accept-Encoding\"><a href=\"#10-Vary-Accept-Encoding\" class=\"headerlink\" title=\"10.Vary: Accept-Encoding\"></a>10.Vary: Accept-Encoding</h5><blockquote>\n<p>告诉缓存服务器，缓存压缩文件和非压缩文件两个版本。</p>\n</blockquote>\n<h4 id=\"6-响应状态码\"><a href=\"#6-响应状态码\" class=\"headerlink\" title=\"6.响应状态码\"></a>6.响应状态码</h4><ul>\n<li><code>100～199</code>：表示服务器成功接收部分请求，要求客户端继续提交其余请求才能完成整个处理过程。</li>\n<li><code>200～299</code>：表示服务器成功接收请求并 已完成整个处理过程。常用<code>200</code>（OK请求成功）。</li>\n<li><code>300～399</code>：为完成请求，客户端需进一步细化请求。例如：请求的资源已经移动一个新地址，常用<code>302</code>（所请求的页面已经临时转移至新的URL）、<code>307</code>和<code>304</code>（使用缓存资源）。</li>\n<li><code>400～499</code>：客户端的请求有错误，常用<code>404</code>（服务器无法找到被请求的页面）、<code>403</code>（服务器拒绝访问，权限不够）。</li>\n<li><code>500～599</code>：服务端出现错误，常用<code>500</code>（请求未完成。服务器遇到不可预知的情况）。</li>\n</ul>\n<h4 id=\"7-Cookie和Session\"><a href=\"#7-Cookie和Session\" class=\"headerlink\" title=\"7.Cookie和Session\"></a>7.Cookie和Session</h4><blockquote>\n<p>服务器和客户端的交互仅限于请求/响应过程，结束之后便断开，在下一次请求时，服务器会认为新的客户端。为了维护他们之间的连接，让服务器知道这是前一个用户发送的请求，必须在一个地方保存客户端的信息。</p>\n</blockquote>\n<ul>\n<li><code>Cooke</code>：通过在客户端记录的信息确定用户的身份。</li>\n<li><code>Session</code>：通过在服务端记录的信息确定用户的身份。</li>\n</ul>\n<h2 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h2><blockquote>\n<p>HTTPS = HTTP + SSL/TLS</p>\n<p>SSL：Secure Sockets Layer 安全套接层</p>\n<p>TLS：ransport Layer Security 安全传输层协议。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）</p>\n</blockquote>\n<h5 id=\"1-客户端发起HTTPS请求\"><a href=\"#1-客户端发起HTTPS请求\" class=\"headerlink\" title=\"1.客户端发起HTTPS请求\"></a>1.客户端发起HTTPS请求</h5><h5 id=\"2-服务端的配置\"><a href=\"#2-服务端的配置\" class=\"headerlink\" title=\"2.服务端的配置\"></a>2.服务端的配置</h5><blockquote>\n<p>采用HTTPS协议的服务器必须有一套数字证书，包含一对公钥和私钥。</p>\n</blockquote>\n<h5 id=\"3-传送证书\"><a href=\"#3-传送证书\" class=\"headerlink\" title=\"3.传送证书\"></a>3.传送证书</h5><blockquote>\n<p>该证书是公钥，包含证书的颁发机构、过期时间等等。</p>\n</blockquote>\n<h5 id=\"4-客户端解析证书\"><a href=\"#4-客户端解析证书\" class=\"headerlink\" title=\"4.客户端解析证书\"></a>4.客户端解析证书</h5><blockquote>\n<p>由客户端的TLS完成，首先验证公钥是否有效，比如颁发机构、过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密。</p>\n</blockquote>\n<h5 id=\"5-传送加密信息\"><a href=\"#5-传送加密信息\" class=\"headerlink\" title=\"5.传送加密信息\"></a>5.传送加密信息</h5><blockquote>\n<p>传送的是用证书加密后的随机值，目的是让服务端得到这个随机值，以后客户端和服务端通信就可以通过这个随机值来进行加密解密了。</p>\n</blockquote>\n<h5 id=\"6-服务端解密信息\"><a href=\"#6-服务端解密信息\" class=\"headerlink\" title=\"6.服务端解密信息\"></a>6.服务端解密信息</h5><blockquote>\n<p>服务端用私钥解密后，得到了客户端传过来的随机值（私钥），然后把内容通过该值进行对称加密。</p>\n</blockquote>\n<h5 id=\"7-传输加密后的信息\"><a href=\"#7-传输加密后的信息\" class=\"headerlink\" title=\"7.传输加密后的信息\"></a>7.传输加密后的信息</h5><h5 id=\"8-客户端解密信息\"><a href=\"#8-客户端解密信息\" class=\"headerlink\" title=\"8.客户端解密信息\"></a>8.客户端解密信息</h5><blockquote>\n<p>客户端用之前生成的私钥解密服务端传过来的信息，于是获取了解密后的内容。</p>\n</blockquote>\n<p><img src=\"./images/HTTP和HTTPS.JPG\" alt=\"RSA密钥交换过程\"></p>\n<h2 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h2><ul>\n<li>HTTP协议是运行在TCP之上，所有传输的内容都是明文，客户端和服务端都无法验证对方的身份。</li>\n<li>HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS是运行在TCP之上。所有传输的内容都是经过加密，加密采用对称加密，但对称加密的密钥用服务器的证书进行了非对称加密。</li>\n</ul>\n<h2 id=\"TCP建立连接的三次握手\"><a href=\"#TCP建立连接的三次握手\" class=\"headerlink\" title=\"TCP建立连接的三次握手\"></a>TCP建立连接的三次握手</h2><blockquote>\n<p><strong>FLAGS字段：</strong></p>\n<p>SYN：表示建立连接。</p>\n<p>FIN：表示关闭连接。</p>\n<p>ACK：表示响应。</p>\n<p>PSH：表示有DATA数据传输。</p>\n<p>RST：表示连接重置。</p>\n</blockquote>\n<ul>\n<li>第一次握手：主机A发送位码为syn＝1，随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机。</li>\n<li>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包。</li>\n<li>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。</li>\n</ul>\n<p>完成三次握手，主机A与主机B开始传送数据。</p>\n<h2 id=\"TCP断开连接的四次握手\"><a href=\"#TCP断开连接的四次握手\" class=\"headerlink\" title=\"TCP断开连接的四次握手\"></a>TCP断开连接的四次握手</h2><blockquote>\n<p>TCP断开连接有两种方式，第一种是正常的四次握手断开的，第二种是RST异常断开的</p>\n</blockquote>\n<h5 id=\"1-正常断开\"><a href=\"#1-正常断开\" class=\"headerlink\" title=\"1.正常断开\"></a>1.正常断开</h5><ul>\n<li>服务器80端口向41826端口发出FIN的断开连接请求。</li>\n<li>41826端口收到请求之后向服务器80端口回复了一个ACK。</li>\n<li>41826端口向服务器80端口发送断开请求FIN。</li>\n<li>服务器80向客户端发送断开的回复ACK。</li>\n</ul>\n<h5 id=\"2-异常断开\"><a href=\"#2-异常断开\" class=\"headerlink\" title=\"2.异常断开\"></a>2.异常断开</h5><ul>\n<li>服务器80端口向41826端口发出FIN的断开连接请求。</li>\n<li>41826端口收到请求之后向服务器80端口回复了一个ACK。</li>\n<li>41826端口向服务器80端口发送了GET请求。</li>\n<li>41826端口向服务器80端口发送断开请求FIN。</li>\n<li>服务器端口80因为原因没有确认客户端发送的确认请求而断开，因此返回了RST。</li>\n</ul>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjg6c1dxv0000gzxfykuktk7b","tag_id":"cjg6c1dy20002gzxfk5gn51lb","_id":"cjg6c1dy60006gzxfhn2j4w5r"},{"post_id":"cjg6c1dxv0000gzxfykuktk7b","tag_id":"cjg6c1dy50004gzxfxpxkcthc","_id":"cjg6c1dy60007gzxfnz1gs0wn"},{"post_id":"cjg6c1dxz0001gzxfpldpnl8o","tag_id":"cjg6c1dy60005gzxf2fp3o6oq","_id":"cjg6c1dy80009gzxfjapl997k"},{"post_id":"cjg6c1dy40003gzxffik8jghn","tag_id":"cjg6c1dy60008gzxf5uheieh5","_id":"cjg6c1dy9000cgzxfr4rfx1u1"},{"post_id":"cjg6c1dy40003gzxffik8jghn","tag_id":"cjg6c1dy8000agzxf7vvk7jf2","_id":"cjg6c1dy9000dgzxfrexzzv60"},{"post_id":"cjg6c1dy40003gzxffik8jghn","tag_id":"cjg6c1dy8000bgzxf1x4qxyyg","_id":"cjg6c1dy9000egzxfo3fnje2c"}],"Tag":[{"name":"Podfile","_id":"cjg6c1dy20002gzxfk5gn51lb"},{"name":"Cocoapods","_id":"cjg6c1dy50004gzxfxpxkcthc"},{"name":"面试","_id":"cjg6c1dy60005gzxf2fp3o6oq"},{"name":"HTTP","_id":"cjg6c1dy60008gzxf5uheieh5"},{"name":"HTTPS","_id":"cjg6c1dy8000agzxf7vvk7jf2"},{"name":"握手","_id":"cjg6c1dy8000bgzxf1x4qxyyg"}]}}