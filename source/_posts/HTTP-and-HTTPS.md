---
title: HTTP和HTTPS对比
date: 2018-04-8 17:16:26
declare: true
comments: true
tags:
- HTTP
- HTTPS
- 握手
---

![top](/assets/blogImg/http-https-top.jpg)

<!-- more -->

> **HTTP协议（HyperText Transfer Protocol，超文本传输协议）**：是一种用于分布式、协作式和超媒体信息系统的应用层协议。目的是为了提供一种发布和接收HTML页面的方法。默认端口号为`80`。
>
> **HTTPS协议（Hypertext Transfer Protocol Secure）**：是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。默认端口号为`443`。
>
> > 引自维基百科[HTTP](https://zh.wikipedia.org/wiki/超文本传输协议)和[HTTPS](https://zh.wikipedia.org/wiki/超文本传输安全协议)

### HTTP

##### 1. 协议概述

​	由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如"HTTP/1.1 200 OK"，以及返回的内容，如请求的文件、错误消息、或者其它信息。

##### 2. URL

> **URL（Uniform / Universal Resource Locator）**：统一资源定位符，是用于完整地描述Internet上网页和其他资源的地址的一种标识方法。

**基本格式**：`scheme://host[:port#]/path/…/[?query-string][#anchor]`

- **scheme**：协议(例如：http, https, ftp)
- **host**：服务器的IP地址或者域名
- **port**#：服务器的端口（如果是走协议默认端口，缺省端口80）
- **path**：访问资源的路径
- **query-string**：参数，发送给http服务器的数据
- **anchor**：锚（跳转到网页的指定锚点位置）

##### 3. 请求方法（HTTP/1.1）

1. **GET**：请求指定的页面信息，并返回实体主体。参数显示在URL中。
2. **HEAD**：类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头。
3. **POST**：向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。参数在请求体中。
4. **PUT**：从客户端向服务器传达的数据取代指定的文档的内容。
5. **DELETE**：请求服务器删除指定的页面。
6. **CONNECT**：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
7. **OPTIONS**：允许客户端查看服务器的性能。
8. **TRACE**：回显服务器收到的请求，主要用于测试或诊断。

> 避免使用`GET`方式提交表单，因为有可能会导致安全问题。比如说在登陆表单中用Get方式，用户输入的用户名和密码将在地址栏中暴露无遗。

##### 4.常用的请求报头

> HTTP请求由四个部分组成，分别是：**请求行**、**请求头部**、**空行**、**请求数据**。

##### 1.Host（主机和端口号）

> **Host**：对应网址URL中的Web名称和端口号，用于指定被请求资源的Internet主机和端口号，通常属于URL的一部分。

##### 2.Connection (链接类型)

> **Connection**：表示客户端与服务连接类型.

1. Client 发起一个包含 `Connection:keep-alive` 的请求，HTTP/1.1使用 `keep-alive` 为默认值。
2. Server收到请求后：
   - 如果 Server 支持 `keep-alive`，回复一个包含 `Connection:keep-alive` 的响应，不关闭连接；
   - 如果 Server 不支持 `keep-alive`，回复一个包含 `Connection:close` 的响应，关闭连接。
3. 如果client收到包含 `Connection:keep-alive` 的响应，向同一个连接发送下一个请求，直到一方主动关闭连接。

> `keep-alive`在很多情况下能够重用连接，减少资源消耗，缩短响应时间，比如当浏览器需要多个文件时(比如一个HTML文件和相关的图形文件)，不需要每次都去请求建立连接。

##### 3.Upgrade-Insecure-Requests (升级为HTTPS请求)

> **Upgrade-Insecure-Requests**：升级不安全的请求，意思是会在加载 http 资源时自动替换成 https 请求，让浏览器不再显示https页面中的http请求警报。

##### 4.User-Agent(浏览器名称)

> **User-Agent**：是客户浏览器的名称。

##### 5.Accept（传输文件类型）

> **Accept**：指浏览器或其他客户端可以接受的MIME（Multipurpose Internet Mail Extensions（多用途互联网邮件扩展））文件类型，服务器可以根据它判断并返回适当的文件格式。

- `Accept: \*/\*`：表示什么都可以接收。
- `Accept: image/gif`：表示客户端希望接收GIF图像格式的资源。
- `Accept: text/html`：表示客户端希望接收html文本。
- `Accept: text/html, application/xhtml+xml;q=0.9, image/*;q=0.8`：表示浏览器支持的MIME类型分别是html文本、xhtml和xml文档、所有的图像格式资源。

> `q`是权重系数，范围0 =< q <= 1，`q`值越大，请求越倾向于获得其“`;`”之前的类型表示的内容。若没有指定`q`值，则默认为1，按照从左到右排序顺序；若被赋值为0，则用于表示浏览器不接收此内容类型。
>
> `Text`：用于标准化的表示的文本信息，文本消息可以是多种字符集和或者多种格式的。
>
> `Application`：用于传输应用程序数据或者二进制数据。

##### 6.Referer（页面跳转处）

> **Referer**：表明产生请求的网页来自于哪个URL，用户是从该 Referer页面访问到当前请求的页面。这个属性可以用来跟踪Web请求来自哪个页面，是从什么网站来的等。例如防盗链原理。

##### 7.Accept-Encoding（文件编解码格式）

> **Accept-Encoding**：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后先解码，然后再检查文件格式，许多情形下这可以减少大量的下载时间。

- `Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0`：如果有多个Encoding同时匹配, 按照q值顺序排列，本例中按顺序支持 gzip, identity压缩编码，支持gzip的浏览器会返回经过gzip编码的HTML页面。 如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。

##### 8.Accept-Language（语言种类）

> **Accept-Langeuage**：指出浏览器可以接受的语言种类，如en或en-us指英语，zh或者zh-cn指中文，当服务器能够提供一种以上的语言版本时要用到。

##### 9.Accept-Charset（字符编码）

> **Accept-Charset**：指出浏览器可以接受的字符编码。

- `Accept-Charset:iso-8859-1,gb2312,utf-8`：本例中支持`ISO8859-1`、`gb2312`、`utf-8`编码。如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。

##### 10.Cookie

> **Cookie**：浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。

##### 11.Content-Type （POST数据类型）

> **Content-Type**：POST请求里用来表示的内容类型。

- `Content-Type = Text/XML; charset=gb2312`：指明该请求中的消息体中包含的是纯文本的`XML`类型的数据，字符编码采用`gb2312`。

##### 5.服务端常用的响应报头

> HTTP响应由四个部分组成，分别是： **状态行**、**消息报头**、**空行**、**响应正文**。

##### 1.Cache-Control: must-revalidate, no-cache, private

> 这个值告诉客户端，服务端不希望客户端缓存资源，在下次请求资源时，必须要重新请求服务器，不能从缓存中获取资源。

- `Cache-Control`是响应头中很重要的信息，当客户端请求头中包含`Cache-Control: max-age = 0`请求，明确表示不会缓存服务器资源时，`Cache-Control`作为回应信息，通常会返回`no-cache`。
- 当客户端在请求头中没有包含`Cache-Control`时，服务端往往会定不同的资源不同的缓存策略，比如说oschina在缓存图片资源的策略是`Cache-Control: max-age = 86400`，这个意思是，从当前时间开始，在86400秒的时间内，客户端可以直接从缓存中读取资源，而不需要向服务器请求。

##### 2.Connection: keep-alive

> 这个字段作为回应客户端的`Connection: keep-alive`，告诉客户端服务器的TCP连接也是一个长连接，客户端可以继续使用这个TCP连接发送HTTP请求。

##### 3.Content-Encoding: gzip

> 告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码。

##### 4.Content-Type: text/html; charset = UTF-8

> 告诉客户端，资源文件的类型和字符编码，客户端通过UTF-8对资源进行解码，然后对资源进行html解析。

##### 5.Date: Sun, 21 Sep 2016 06:18:21 GMT

> 服务端发送资源时的服务器时间。

##### 6.Expires: Sun, 1 Jan 2000 01:00:00 GMT

> 告诉客户端可以在这个时间前直接访问缓存。该值存在问题，客户端和服务器的时间不一定都是相同的，所有没有`Cache-Control: max-age = *` 准确。

##### 7.Pragma: no-cache

> 含义与`Cache-Control`相同

##### 8.Server: Tengine/1.4.6

> 服务器和相对应的版本，告诉客户端服务器的信息。

##### 9.Transfer-Encoding: chunked

> 告诉客户端，服务器发送的资源方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。

##### 10.Vary: Accept-Encoding

> 告诉缓存服务器，缓存压缩文件和非压缩文件两个版本。

##### 6.响应状态码

- `100～199`：表示服务器成功接收部分请求，要求客户端继续提交其余请求才能完成整个处理过程。
- `200～299`：表示服务器成功接收请求并 已完成整个处理过程。常用`200`（OK请求成功）。
- `300～399`：为完成请求，客户端需进一步细化请求。例如：请求的资源已经移动一个新地址，常用`302`（所请求的页面已经临时转移至新的URL）、`307`和`304`（使用缓存资源）。
- `400～499`：客户端的请求有错误，常用`404`（服务器无法找到被请求的页面）、`403`（服务器拒绝访问，权限不够）。
- `500～599`：服务端出现错误，常用`500`（请求未完成。服务器遇到不可预知的情况）。

##### 7.Cookie和Session

> 服务器和客户端的交互仅限于请求/响应过程，结束之后便断开，在下一次请求时，服务器会认为新的客户端。为了维护他们之间的连接，让服务器知道这是前一个用户发送的请求，必须在一个地方保存客户端的信息。

- `Cooke`：通过在客户端记录的信息确定用户的身份。
- `Session`：通过在服务端记录的信息确定用户的身份。

### HTTPS

> HTTPS = HTTP + SSL/TLS
>
> SSL：Secure Sockets Layer 安全套接层
>
> TLS：ransport Layer Security 安全传输层协议。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）

##### 1.客户端发起HTTPS请求

##### 2.服务端的配置

> 采用HTTPS协议的服务器必须有一套数字证书，包含一对公钥和私钥。

##### 3.传送证书

> 该证书是公钥，包含证书的颁发机构、过期时间等等。

##### 4.客户端解析证书

> 由客户端的TLS完成，首先验证公钥是否有效，比如颁发机构、过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密。

##### 5.传送加密信息

> 传送的是用证书加密后的随机值，目的是让服务端得到这个随机值，以后客户端和服务端通信就可以通过这个随机值来进行加密解密了。

##### 6.服务端解密信息

> 服务端用私钥解密后，得到了客户端传过来的随机值（私钥），然后把内容通过该值进行对称加密。

##### 7.传输加密后的信息

##### 8.客户端解密信息

> 客户端用之前生成的私钥解密服务端传过来的信息，于是获取了解密后的内容。

![RSA密钥交换过程](/assets/blogImg/http-https.jpg)

### 不同点

- HTTP协议是运行在TCP之上，所有传输的内容都是明文，客户端和服务端都无法验证对方的身份。
- HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS是运行在TCP之上。所有传输的内容都是经过加密，加密采用对称加密，但对称加密的密钥用服务器的证书进行了非对称加密。

### TCP建立连接的三次握手

> **FLAGS字段：**
>
> SYN：表示建立连接。
>
> FIN：表示关闭连接。
>
> ACK：表示响应。
>
> PSH：表示有DATA数据传输。
>
> RST：表示连接重置。

- 第一次握手：主机A发送位码为syn＝1，随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机。
- 第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包。
- 第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。

完成三次握手，主机A与主机B开始传送数据。

### TCP断开连接的四次握手

> TCP断开连接有两种方式，第一种是正常的四次握手断开的，第二种是RST异常断开的

##### 1.正常断开

- 服务器80端口向41826端口发出FIN的断开连接请求。
- 41826端口收到请求之后向服务器80端口回复了一个ACK。
- 41826端口向服务器80端口发送断开请求FIN。
- 服务器80向客户端发送断开的回复ACK。

##### 2.异常断开

- 服务器80端口向41826端口发出FIN的断开连接请求。
- 41826端口收到请求之后向服务器80端口回复了一个ACK。
- 41826端口向服务器80端口发送了GET请求。
- 41826端口向服务器80端口发送断开请求FIN。
- 服务器端口80因为原因没有确认客户端发送的确认请求而断开，因此返回了RST。